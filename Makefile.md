### 1. 核心格式（目标-依赖-命令）
```makefile
# 命令必须以【Tab】开头（不能用空格）
目标名: 依赖1 依赖2
	命令1  # 例如 gcc -c main.c
	命令2  # 例如 gcc main.o tool.o -o app
```
PS：执行命令的前提：目标不存在或在依赖文件的更新时间比目标新
### 2. 变量
格式为 `变量名=值`，引用时用 `$(变量名)`
- **示例**：
  ```makefile
  CC = gcc          # 定义
  $(TARGET): $(OBJS)# 引用
  ```
### 3. 伪目标（.PHONY）
用于定义“不是文件”的目标，避免与同名文件冲突，格式为 `PHONY: 伪目标名`
若无伪目标定义，当存在和目标同名的文件时，由于文件没有更新，所以不会执行伪目标的命令
- **示例**：定义 `clean` 伪目标，用于删除编译生成的文件
  ```makefile
  .PHONY: clean  # 声明clean是伪目标
  clean:
  	rm -f $(TARGET) $(OBJS)  # 删除app、main.o、tool.o
  ```
- **使用**：执行 `make clean` 即可触发清理命令。
```
### 一、通配符（简化文件匹配）

| 通配符 | 作用                          | 示例                                  |
|--------|-------------------------------|---------------------------------------|
| `*`    | 匹配任意个字符（包括 0 个）   | `*.c` 匹配所有 `.c` 源文件；`app*` 匹配所有以 `app` 开头的文件 |
| `?`    | 匹配单个任意字符              | `main?.c` 匹配 `main1.c`、`mainA.c` 等 |
| `[]`   | 匹配括号内任意一个字符        | `main[1-3].c` 匹配 `main1.c`、`main2.c`、`main3.c` |

#### 关键注意点：
2. **变量中使用场景**：若通配符在变量中，直接引用变量时可能无法解析（需结合 `wildcard` 函数强制解析）。  
   错误示例（变量中 `*.c` 会被当作普通字符串，而非通配符）：  
   ```makefile
   SRC = *.c  # 此时SRC的值是字符串"*.c"，不是实际的.c文件列表
   app: $(SRC)
       gcc $(SRC) -o app  # 可能报错“找不到*.c文件”
   ```
### 二、即时变量与延时变量（控制变量生效时机）
#### 1. 即时变量（立即展开，`:=` 赋值）
- **规则**：变量定义时，立即计算并存储结果，后续引用时直接使用已存储的结果，不受后续变量修改影响。  
  ```makefile
  A := 123          # 定义即时变量A，立即存储“123”
  B := $(A) 456     # 定义时立即解析$(A)，B存储“123 456”
  A := 789          # 后续修改A，不影响已定义的B
  all:
      @echo B = $(B)  # 执行make，输出“B = 123 456”（B的值不变）
  ```
#### 2. 延时变量（延迟展开，`=` 赋值）
- **规则**：变量定义时不计算结果，仅存储“表达式”；只有当变量被**使用**时（如执行命令、其他变量引用），才会解析表达式，受后续变量修改影响。  
  ```makefile
  A = 123           # 定义延时变量A，存储表达式“123”
  B = $(A) 456      # 定义时不解析，存储表达式“$(A) 456”
  A = 789           # 后续修改A，表达式变为“789”
  all:
      @echo B = $(B)  # 使用B时才解析，$(A)取最新值789，输出“B = 789 456”
  ```
### 一、%核心用法：模式规则（批量匹配目标与依赖）
`%` 可以理解为“通配符占位符”，在**目标**和**依赖**中必须成对出现，代表“相同的字符串片段”。  
最典型场景：批量将所有 `.c` 源文件编译为对应的 `.o` 目标文件（如 `main.c` → `main.o`，`tool.c` → `tool.o`）。

#### 示例：批量生成 .o 文件
```makefile
# 模式规则：% 匹配相同的文件名前缀（如 main、tool）
# 目标：%.o（所有以 .o 结尾的文件）
# 依赖：%.c（对应前缀的 .c 源文件）
%.o: %.c
    gcc -c $< -o $@  # 编译命令：$< 代表“第一个依赖文件”，$@ 代表“当前目标文件”
```
- 当执行 `make main.o` 时，`%` 匹配 `main`，规则自动变为：`main.o: main.c`，执行 `gcc -c main.c -o main.o`。
- 当执行 `make tool.o` 时，`%` 匹配 `tool`，规则自动变为：`tool.o: tool.c`，执行 `gcc -c tool.c -o tool.o`。
在 Makefile 中，`$@` 和 `$<` 是**自动变量**（Automatic Variables），核心作用是在规则中动态指代目标、依赖等内容，避免重复书写具体文件名，尤其配合模式规则（`%`）使用时效率极高。

### 1. `$@`：指代当前规则的“目标文件”
- **含义**：自动替换为当前规则中定义的“目标”（可以是单个文件，也可以是多个目标中的当前一个）。
- **场景**：常用于编译、链接命令中，明确输出文件。
#### 示例 1：单个目标规则
```makefile
# 目标是 main.o，$@ 即指代 main.o
main.o: main.c
    gcc -c main.c -o $@  # 等价于：gcc -c main.c -o main.o
```
#### 示例 2：配合模式规则（批量目标）
```makefile
# 模式规则：目标是 %.o（如 a.o、b.o），$@ 动态指代当前目标（a.o 或 b.o）
%.o: %.c
    gcc -c $< -o $@  # 编译 a.c 时，$@=a.o；编译 b.c 时，$@=b.o
```
### 2. `$<`：指代当前规则的“第一个依赖文件”
- **含义**：自动替换为当前规则中“第一个依赖项”（无论依赖有多少个，只取第一个）。
- **场景**：最常用在编译规则中（单个源文件生成单个目标文件）。

#### 示例 1：单个依赖规则
```makefile
# 依赖是 main.c（第一个依赖），$< 即指代 main.c
main.o: main.c
    gcc -c $< -o main.o  # 等价于：gcc -c main.c -o main.o
```
#### 示例 2：配合模式规则（批量依赖）
```makefile
# 依赖是 %.c（当前目标对应的 .c 文件，即第一个依赖）
%.o: %.c
    gcc -c $< -o $@  # 编译 a.o 时，$<=a.c；编译 b.o 时，$<=b.c
```
### 2. `$^`：指代当前规则的“所有依赖文件”
 94 - **含义**：自动替换为当前规则中“所有依赖项”

### 一、字符串处理函数
#### 1. `$(subst 旧字符串,新字符串,源字符串)`
- **功能**：替换字符串中的指定内容
- **示例**：
  ```makefile
  str = "hello world"
  new_str = $(subst world,makefile,$(str))  # 结果："hello makefile"
  ```


#### 2. `$(patsubst 模式,替换模式,源字符串)`
- **功能**：按模式匹配替换（支持通配符 `%`）
- **示例**：
  ```makefile
  files = a.c b.c c.c
  objs = $(patsubst %.c,%.o,$(files))  # 结果：a.o b.o c.o
  ```


#### 3. `$(strip 字符串)`
- **功能**：去除字符串前后的空格和空行
- **示例**：
  ```makefile
  str = "  hello  "
  new_str = $(strip $(str))  # 结果："hello"
  ```


### 二、文件名处理函数
#### 1. `$(wildcard 模式)`
- **功能**：匹配当前目录中符合模式的文件（返回文件名列表）
- **示例**：
  ```makefile
  src_files = $(wildcard *.c)  # 匹配所有 .c 文件，如：main.c tool.c
  ```


#### 2. `$(notdir 路径列表)`
- **功能**：从路径中提取文件名（去掉目录部分）
- **示例**：
  ```makefile
  paths = src/main.c src/tool.c
  files = $(notdir $(paths))  # 结果：main.c tool.c
  ```


#### 3. `$(dir 路径列表)`
- **功能**：从路径中提取目录部分
- **示例**：
  ```makefile
  paths = src/main.c src/tool.c
  dirs = $(dir $(paths))  # 结果：src/ src/
  ```


#### 4. `$(addprefix 前缀,文件名列表)`
- **功能**：给文件名列表添加前缀
- **示例**：
  ```makefile
  files = a.o b.o
  obj_files = $(addprefix obj/,$(files))  # 结果：obj/a.o obj/b.o
  ```


#### 5. `$(addsuffix 后缀,文件名列表)`
- **功能**：给文件名列表添加后缀
- **示例**：
  ```makefile
  names = main tool
  src_files = $(addsuffix .c,$(names))  # 结果：main.c tool.c
  ```


### 三、其他实用函数
#### 1. `$(foreach 变量,列表,表达式)`
- **功能**：遍历列表，对每个元素执行表达式
- **示例**：
  ```makefile
  files = a b c
  obj_files = $(foreach f,$(files),$(f).o)  # 结果：a.o b.o c.o
  ```


#### 2. `$(if 条件,为真时的值,为假时的值)`
- **功能**：条件判断（条件非空则为真）
- **示例**：
  ```makefile
  debug = 1
  cflags = $(if $(debug),-g -O0,-O2)  # 若 debug 非空，结果：-g -O0；否则：-O2
  ```


#### 3. `$(shell 命令)`
- **功能**：执行 Shell 命令并返回结果
- **示例**：
  ```makefile
  date = $(shell date +%Y-%m-%d)  # 获取当前日期，如：2023-10-01
  ```


### 四、实战示例：自动生成依赖
结合上述函数，可实现自动查找源文件、生成目标文件列表：
```makefile
# 自动查找所有 .c 文件
SRC_FILES = $(wildcard *.c src/*.c)

# 将 .c 文件转换为 obj 目录下的 .o 文件
OBJ_FILES = $(addprefix obj/,$(patsubst %.c,%.o,$(notdir $(SRC_FILES))))

# 创建 obj 目录（如果不存在）
$(shell mkdir -p obj)

# 编译规则
obj/%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

obj/%.o: src/%.c
	$(CC) $(CFLAGS) -c $< -o $@
```
