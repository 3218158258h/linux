#### 串口核心概念
串口（UART）是嵌入式Linux中常用的**设备间异步通信接口**，通过TX/RX信号线传输数据，支持全双工通信，广泛应用于传感器、模块（如GPS、蓝牙）、调试日志输出等场景。Linux将串口抽象为字符设备文件（如 `/dev/ttyS0`、`/dev/ttyUSB0`），通过文件IO接口操作。

#### 核心结构体：`struct termios`（串口属性配置结构体）
`struct termios` 是 POSIX 标准定义的串口配置核心结构体，封装了串口的输入输出模式、控制规则、波特率等所有关键参数，嵌入式 Linux 串口配置本质就是修改该结构体的成员并应用生效。核心成员及功能说明如下：
```c
struct termios {
    tcflag_t c_cflag;  // 硬件控制模式标志（核心：数据位、校验位、停止位、硬件流控）
    tcflag_t c_iflag;  // 输入处理模式标志（如奇偶校验错误处理、换行/回车转换）
    tcflag_t c_oflag;  // 输出处理模式标志（如换行转换、波特率适配、字符扩展）
    tcflag_t c_lflag;  // 本地控制模式标志（如回显、规范/原始模式、信号触发）
    cc_t     c_cc[NCCS];// 控制字符集合（如超时时间、最小读取字节数、中断字符等）
    speed_t  c_ispeed; // 输入波特率（数值型，需通过专用函数设置）
    speed_t  c_ospeed; // 输出波特率（数值型，需通过专用函数设置）
};
```
- **核心成员详细说明**：
  1. **`c_cflag`（硬件控制核心，直接位操作配置）**  
     负责定义串口硬件层面的通信规则，无需专用函数，通过“清除旧标志 + 置位新标志”的位掩码操作配置：
     - 数据位：`CS5`（5位）、`CS6`（6位）、`CS7`（7位）、`CS8`（8位，最常用）；需先通过 `~CSIZE` 清除原有数据位配置
     - 校验位：`PARENB`（使能校验位）为基础，搭配 `PARODD`（奇校验）/ 无 `PARENB` 则为无校验（最常用）；无 `PARODD`（偶校验）
     - 停止位：`CSTOPB`（2位停止位）；无 `CSTOPB` 则为1位停止位（最常用）
     - 硬件流控：`CRTSCTS`（使能 RTS/CTS 硬件流控）；默认无该标志（禁用流控）
     - 基础使能：`CLOCAL`（忽略调制解调器状态，嵌入式串口必设）、`CREAD`（启用串口接收功能，必设）

  2. **`c_ispeed`/`c_ospeed`（波特率存储，需专用函数配置）**  
     分别存储输入、输出波特率的数值（如 115200 对应的底层编码），**禁止直接赋值修改**（不同系统编码格式不同，兼容性差），必须通过 `cfsetispeed`/`cfsetospeed` 函数设置（POSIX 标准兼容接口）。

  3. **`c_iflag`（输入处理模式）**  
     控制串口接收数据后的软件处理规则，常用配置：
     - `IGNPAR`：忽略奇偶校验错误的字符
     - `ICRNL`：将接收的回车符（CR）转换为换行符（NL）（规范模式常用，原始模式禁用）
     - `IXON`/`IXOFF`：启用 XON/XOFF 软件流控（默认禁用，避免与硬件流控冲突）

  4. **`c_oflag`（输出处理模式）**  
     控制串口发送数据前的软件处理规则，常用配置：
     - `OPOST`：启用输出处理（如换行转换）；原始模式需禁用（`~OPOST`），避免修改发送数据
     - `ONLCR`：将发送的换行符（NL）转换为回车+换行（CR+NL）（规范模式常用）

  5. **`c_lflag`（本地控制模式）**  
     控制串口的本地交互特性，核心区分“规范模式”和“原始模式”（嵌入式串口通信必用原始模式）：
     - 规范模式（默认）：按行读取数据（以回车/换行为结束符），启用回显、信号触发（如 Ctrl+C 中断）
     - 原始模式（串口通信首选）：禁用行缓冲、回显、信号触发，数据实时收发，需配置：
       ```c
       c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG); 
       // ICANON：禁用规范模式 → 原始模式
       // ECHO/ECHOE：禁用输入回显（避免发送数据回显到接收端）
       // ISIG：禁用信号触发（避免串口数据误触发进程信号）
       ```
       **或者直接调用cfmakeraw(&attr)一键清除规范模式的配置，进入原始模式**
       ```c
       #include <termios.h>
       void cfmakeraw(struct termios *termios_p);
       ```

  6. **`c_cc[NCCS]`（控制字符）**  
     存储串口的控制字符及超时参数，核心配置（原始模式常用）：
     - `VMIN`：最小读取字节数（如设为 1，`read` 至少读取 1 字节才返回。如设为0：read不等待最小字节数，有数据就返回，无数据立即返回）
     - `VTIME`：读取超时时间，在`c_cc[VMIN]>0`的前提下有效（单位：0.1 秒，如设为 10 → 超时 1 秒；设为 0 → 无限阻塞）
     示例配置（1 秒超时，至少读 1 字节）：
     ```c
     attr.c_cc[VMIN] = 1;   // 最小读取 1 字节
     attr.c_cc[VTIME] = 10; // 超时 1 秒（10 × 0.1s）
     ```
#### 清除修改说明/示例

  - `c_cflag` 的二进制是 `0001 0100`（仅举例），其中某几位对应：
  - 第3位：`PARENB`（校验位开关，1=开，0=关）
  - 第5位：`CSTOPB`（2位停止位开关，1=开，0=关）
  - 其他位：对应数据位、流控等其他功能

我们要修改“校验位”时，不能直接把整个面板换掉（直接赋值），而是要：
1. 先找到“校验位开关”（`PARENB` 对应的比特位），把它**关掉**（清除旧标志）；
2. 再根据需求，把“校验位开关”或“奇校验开关”**打开**（置位新标志）；
3. 其他开关（如数据位、停止位）保持不变。


- 互斥多选一：多个选项只能选一个，不能同时生效（比如数据位：5/6/7/8 位，只能选一种）需要「先清除，后置位」

- 二选一开关：只有 “启用” 和 “禁用” 两种状态，无其他选项（比如校验位：启用 / 禁用；停止位：1 位 / 2 位；流控：启用 / 禁用）。只需「仅清除」或「仅置位」

**位操作的核心运算符**
实现“清除旧标志+置位新标志”依赖3个二进制运算符，对应串口配置的核心场景：

| 运算符 | 作用                  | 串口配置场景                  | 示例（假设 `old` 是旧配置）          |
|--------|-----------------------|-------------------------------|---------------------------------------|
| `&=` ~ | 清除指定标志（关开关） | 禁用某功能（如校验位、2位停止位） | `old &= ~PARENB` → 关闭校验位开关     |
| `|=`   | 置位指定标志（开开关） | 启用某功能（如8位数据位、硬件流控） | `old |= CS8` → 打开8位数据位开关     |
| `&=`   | 保留指定标志（锁开关） | 仅保留目标功能，禁用其他（极少用） | `old &= CSIZE` → 仅保留数据位相关配置 |

注：`~` 是“按位取反”，比如 `PARENB` 是某个比特位为1的数，`~PARENB` 就是该位为0、其他位为1的数。


#### 三、代码演示：逐功能拆解“清除+置位”逻辑
以嵌入式最常用的 **8N1 配置**（8数据位、无校验、1停止位、无流控）为例，逐行演示每个配置的“清除旧标志+置位新标志”过程：

```c
struct termios attr;
tcgetattr(uart_fd, &attr); // 从串口读取当前配置到 attr
// 此时 attr.c_cflag 存储着系统默认或上一次的配置（旧标志）
```

#### 1. 配置数据位（8位）：先清后置，避免冲突
数据位由 `CS5/CS6/CS7/CS8` 控制，但这4个标志共享同一个“数据位掩码”`CSIZE`（即它们对应 `c_cflag` 中的同一组比特位，只能选一个）。  
如果不先清除旧标志，直接置位 `CS8`，可能导致多个数据位标志同时有效（比如旧配置是 `CS7`，直接 `|= CS8` 会变成 `CS7 | CS8`，串口识别异常）。

**代码演示**：
```c
// 步骤1：清除旧的数据位配置（关所有数据位开关）
attr.c_cflag &= ~CSIZE;  // CSIZE 是数据位的掩码（比如二进制 0000 1111）
// 解释：~CSIZE → 二进制 1111 0000，与 c_cflag 按位与（&）后，
// 数据位对应的4个比特位全变为0（其他位不变），相当于“关闭所有数据位开关”

// 步骤2：置位新的数据位配置（开8位数据位开关）
attr.c_cflag |= CS8;     // CS8 对应二进制 0000 1000
// 解释：与 c_cflag 按位或（|）后，数据位对应的比特位变为 1000（其他位不变），
// 相当于“打开8位数据位开关”
```


#### 2. 配置停止位（1位）：仅清除，不置位
停止位由 `CSTOPB` 控制：
- 1位停止位（默认）：清除 `CSTOPB`（该位为0）；
- 2位停止位：置位 `CSTOPB`（该位为1）。

**代码演示（1位停止位）**：
```c
// 步骤：清除 CSTOPB 标志（关闭2位停止位开关，默认1位）
attr.c_cflag &= ~CSTOPB;  // CSTOPB 是2位停止位标志
// 解释：按位与后，CSTOPB 对应的位变为0，其他位不变，串口默认使用1位停止位
```



整合以上步骤，完整展示“清除旧标志+置位新标志”的整体流程：
```c
struct termios attr;
tcgetattr(uart_fd, &attr); // 1. 获取旧配置

// 2. 配置 c_cflag（硬件核心：8N1+无流控）
attr.c_cflag |= CLOCAL | CREAD;  // 启用核心功能
attr.c_cflag &= ~PARENB;         // 清除校验位使能 → 无校验
attr.c_cflag &= ~CSTOPB;         // 清除2位停止位 → 1位停止位
attr.c_cflag &= ~CSIZE;          // 清除旧数据位配置
attr.c_cflag |= CS8;             // 置位8位数据位
attr.c_cflag &= ~CRTSCTS;        // 清除硬件流控 → 禁用

// 3. 配置原始模式（c_lflag/c_iflag/c_oflag）
attr.c_lflag &= ~(ICANON | ECHO | ISIG); // 清除规范模式、回显、信号触发 → 原始模式
attr.c_iflag &= ~(IXON | IXOFF);         // 清除软件流控 → 禁用
attr.c_oflag &= ~OPOST;                  // 清除输出处理 → 不修改发送数据

// 4. 配置波特率（专用函数，不能位操作）
cfsetispeed(&attr, B115200);
cfsetospeed(&attr, B115200);

// 5. 应用配置（使修改生效）
tcsetattr(uart_fd, TCSANOW, &attr);
```




---

#### `open`（串口设备打开）
`open` 是操作串口的第一步，用于打开串口对应的设备文件，获取文件描述符，后续所有串口操作（配置、读写）均基于该描述符。
```c
#include <fcntl.h>
#include <unistd.h>
int open(const char *pathname, int oflag);
```
- **参数**：
  - `pathname`：串口设备文件路径（如 `/dev/ttyS0` 对应物理串口，`/dev/ttyUSB0` 对应USB转串口）
  - `oflag`：打开方式标志，核心组合：
    - `O_RDWR`：读写方式打开（串口通信需同时支持收发）
    - `O_NOCTTY`：不将串口设为当前进程的控制终端（避免进程接收串口信号干扰）
    - `O_NDELAY`/`O_NONBLOCK`：非阻塞模式（读写时不阻塞进程，立即返回）；默认阻塞模式（读写需等待数据/缓冲区可用）
- **返回值**：成功返回串口文件描述符（`int` 类型）；失败返回 `-1` 并设置 `errno`（如 `ENOENT` 设备不存在、`EACCES` 权限不足）

---

#### `tcgetattr`（获取串口当前属性）
`tcgetattr` 用于读取串口的当前配置属性（波特率、数据位、校验位等），是修改串口配置的前置步骤（需先获取默认属性，再按需修改）。
```c
#include <termios.h>
#include <unistd.h>
int tcgetattr(int fd, struct termios *termios_p);
```
- **参数**：
  - `fd`：串口文件描述符（由 `open` 返回）
  - `termios_p`：指向 `struct termios` 结构体的指针，用于存储读取到的串口属性
- **返回值**：成功返回 `0`；失败返回 `-1` 并设置 `errno`





#### `cfsetispeed`/`cfsetospeed`（设置串口波特率）
用于设置串口的输入/输出波特率（嵌入式常用波特率：9600、19200、38400、115200），需在 `tcgetattr` 之后、`tcsetattr` 之前调用。
```c
#include <termios.h>
int cfsetispeed(struct termios *termios_p, speed_t speed); // 设置输入波特率
int cfsetospeed(struct termios *termios_p, speed_t speed); // 设置输出波特率
```
- **参数**：
  - `termios_p`：指向 `struct termios` 的指针（已通过 `tcgetattr` 获取）
  - `speed`：波特率宏定义（如 `B9600`、`B115200`，需包含 `<termios.h>`）
- **返回值**：成功返回 `0`；失败返回 `-1` 并设置 `errno`

---

#### `tcsetattr`（应用串口配置）
将修改后的 `struct termios` 结构体配置应用到串口，使配置生效。
```c
#include <termios.h>
#include <unistd.h>
int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
```
- **参数**：
  - `fd`：串口文件描述符
  - `optional_actions`：配置生效时机（核心选项）：
    - `TCSANOW`：立即生效（无需等待当前串口操作完成）
    - `TCSADRAIN`：等待所有输出数据发送完成后生效（适用于需确保数据发送完再改配置的场景）
    - `TCSAFLUSH`：清空输入/输出缓冲区后生效
  - `termios_p`：指向已修改好的 `struct termios` 结构体的指针
- **返回值**：成功返回 `0`；失败返回 `-1` 并设置 `errno`

---


#### `tcflush`（清空串口缓冲区）
用于清空串口的输入缓冲区（已接收但未读取的数据）或输出缓冲区（已写入但未发送的数据）。
```c
#include <termios.h>
#include <unistd.h>
int tcflush(int fd, int queue_selector);
```
- **参数**：
  - `fd`：串口文件描述符
  - `queue_selector`：缓冲区类型：
    - `TCIFLUSH`：清空输入缓冲区
    - `TCOFLUSH`：清空输出缓冲区
    - `TCIOFLUSH`：同时清空输入和输出缓冲区
- **返回值**：成功返回 `0`；失败返回 `-1` 并设置 `errno`

---

#### `close`（关闭串口设备）
串口操作完成后，需调用 `close` 关闭文件描述符，释放系统资源。
```c
#include <unistd.h>
int close(int fd);
```
- **参数**：`fd`：串口文件描述符
- **返回值**：成功返回 `0`；失败返回 `-1` 并设置 `errno`

---

#### 串口配置核心流程（嵌入式Linux常用）
1. **打开串口**：使用 `open` 打开设备文件，指定 `O_RDWR | O_NOCTTY` 模式
2. **获取当前属性**：用 `tcgetattr` 读取默认配置到 `struct termios`
3. **修改配置**：
   - 禁用不必要的标志（如回显、规范模式，串口通信常用原始模式）
   - 设置波特率（`cfsetispeed`/`cfsetospeed`）
   - 配置数据位、校验位、停止位（修改 `c_cflag`）
   - （可选）设置控制字符（如最小读取字节数、超时时间）
4. **应用配置**：用 `tcsetattr` 使配置生效（推荐 `TCSANOW`）
5. **清空缓冲区**：用 `tcflush` 清空历史数据，避免干扰
6. **数据读写**：通过 `read`/`write` 收发数据
7. **关闭串口**：操作完成后用 `close` 释放文件描述符


