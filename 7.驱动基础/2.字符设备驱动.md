## 字符设备驱动框架
- 1.驱动初始化
  - 分配设备号
    - 静态分配设备号 → register_chrdev_region
    - 动态分配设备号 → alloc_chrdev_region
    - 操作设备号 dev_t
      - 宏MAJOR → 用于从dev_t中获取主设备号
      - 宏MINOR → 用于从dev_t中获取次设备号
      - 宏MKDEV → 用于将给定的主设备号和次设备号组合成dev_t类型的设备号
  - 初始化cdev → cdev_init
  - 注册cdev → cdev_add
  - 初始化硬件
- 2.构建file_operations
  - open
  - read → copy_to_user
  - write → copy_from_user
  - close
- 3.生成设备节点
  - 自动生成设备节点
    - 创建一个class → class_create
    - 创建一个设备 → device_create
  - 手动生成设备节点 → mknod命令
- 4.驱动卸载
  - 释放设备号 → unregister_chrdev_region
  - 卸载cdev → cdev_del
  - 卸载设备 → device_destroy
  - 卸载class → class_destroy
## 申请字符设备号
**字符设备号**
Linux 中设备以文件形式存在于 `/dev` 目录（称为设备文件），应用程序通过操作设备文件实现对硬件的控制。为管理设备，系统为每个设备分配设备号，分为**主设备号**（区分设备类型）和**次设备号**（区分同一类型的多个设备）。  

**设备号的组成**
设备号由 `dev_t` 类型表示（定义于 `include/linux/types.h`），本质是32位变量：  
```c
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
```  
- 高12位：主设备号（范围0~4095）；  
- 低20位：次设备号。  

内核提供了操作设备号的宏（定义于 `include/linux/kdev_t.h`）：  
| 宏定义                | 功能描述                                  |
|-----------------------|-------------------------------------------|
| `MINORBITS`           | 次设备号位数（20位）                      |
| `MINORMASK`           | 次设备号掩码（`(1U << MINORBITS) - 1`）   |
| `MAJOR(dev)`          | 从 `dev_t` 中提取主设备号                 |
| `MINOR(dev)`          | 从 `dev_t` 中提取次设备号                 |
| `MKDEV(ma, mi)`       | 将主设备号（ma）和次设备号（mi）合并为 `dev_t` |  


**设备号的分配**  

**静态分配设备号**  
开发者手动指定设备号，需确保未被系统占用（可通过 `cat /proc/devices` 查看已用主设备号）。  
- 函数：`int register_chrdev_region(dev_t *dev, unsigned count, const char *name)`  
  - 参数：  
    - `dev`：设备号起始值（`dev_t` 类型）；  
    - `count`：申请的次设备号数量；  
    - `name`：设备名称（会显示在 `/proc/devices` 中）；  
  - 返回值：成功返回0，失败返回负数。  


**动态分配设备号**  
由系统自动分配未使用的设备号，避免冲突（推荐使用）。  
- 函数：`int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)`  
  - 参数：  
    - `dev`：用于保存申请到的设备号；  
    - `baseminor`：次设备号起始值（通常为0）；  
    - `count`：申请的设备号数量；  
    - `name`：设备名称；  
  - 返回值：成功返回0，失败返回负数（优先分配234~255范围内的主设备号）。  


**注销设备号**  
驱动卸载时需释放设备号，避免资源泄露。  
- 函数：`void unregister_chrdev_region(dev_t from, unsigned count)`  
  - 参数：  
    - `from`：要释放的起始设备号；  
    - `count`：释放的设备号数量。  


**编写驱动例程**  
通过 `chrdev.c` 实现静态/动态注册字符设备号的逻辑，代码如下：  

```c
#include <linux/init.h>    // 初始化头文件
#include <linux/module.h>  // 模块基础支持
#include <linux/fs.h>      // 文件操作相关定义
#include <linux/kdev_t.h>  // 设备号操作宏

#define DEVICE_NUMBER       1               // 次设备号数量
#define DEVICE_SNAME        "schrdev"       // 静态注册设备名称
#define DEVICE_ANAME        "achrdev"       // 动态注册设备名称
#define DEVICE_MINOR_NUMBER 0               // 次设备号起始值

static int major_num, minor_num;            // 主/次设备号（通过模块参数传入）

// 注册模块参数：允许加载时传入主/次设备号
module_param(major_num, int, S_IRUSR);
module_param(minor_num, int, S_IRUSR);

static int hello_init(void) {
    dev_t dev_num;  // 设备号
    int ret;        // 函数返回值

    if (major_num) {//若传入主设备号
        // 静态注册设备号
        printk("major_num = %d\n", major_num);//打印传入进来的主设备号
        printk("minor_num = %d\n", minor_num);//打印传入进来的次设备号
        
        dev_num = MKDEV(major_num, minor_num);  // 合并主/次设备号

        //注册设备号
        ret = register_chrdev_region(dev_num, DEVICE_NUMBER, DEVICE_SNAME);
        if (ret < 0) {
            printk("register_chrdev_region error\n");
            return ret;
        }
        printk("register_chrdev_region ok\n");
    } else {//若未传入主设备号
        // 动态注册设备号
        ret = alloc_chrdev_region(&dev_num, DEVICE_MINOR_NUMBER, DEVICE_NUMBER, DEVICE_ANAME);
        if (ret < 0) {
            printk("alloc_chrdev_region error\n");
            return ret;
        }
        printk("alloc_chrdev_region ok\n");
        
        // 从分配的设备号中提取主/次设备号
        major_num = MAJOR(dev_num);
        minor_num = MINOR(dev_num);
        printk("major_num = %d\n", major_num);
        printk("minor_num = %d\n", minor_num);
    }
    return 0;
}

static void hello_exit(void) {
    // 注销设备号
    unregister_chrdev_region(MKDEV(major_num, minor_num), DEVICE_NUMBER);
    printk("goodbye! \n");
}

module_init(hello_init);   // 模块入口
module_exit(hello_exit);   // 模块出口
MODULE_LICENSE("GPL");     // 声明许可证
```  

**编译配置（Makefile）**  
```makefile
obj-m += chrdev.o  # 生成的中间文件名
KDIR := /home/topeet/driver/imx6ull/linux-imx-rel_imx_4.1.15_2.1.0_ga/  # 内核源码路径
PWD ?= $(shell pwd)  # 当前目录路径

all:
    make -C $(KDIR) M=$(PWD) modules  # 编译模块
```  
执行 `make` 生成 `chrdev.ko` 驱动模块。  


**静态注册设备号测试**  
1. 查看系统已用主设备号，选择未被占用的编号（例如9）：  
   ```bash
   cat /proc/devices
   ```  
2. 通过NFS将驱动加载到开发板，传入主设备号9：  
   ```bash
   cd /mnt/nfs/imx6ull/chrdev/
   insmod chrdev.ko major_num=9
   ```  
3. 验证设备号注册成功（查看 `/proc/devices` 中是否存在 `schrdev`）：  
   ```bash
   cat /proc/devices
   ```  
4. 卸载驱动，验证设备号释放：  
   ```bash
   rmmod chrdev
   cat /proc/devices  # "schrdev" 应消失
   ```  


**动态注册设备号测试**  
1. 不传入主设备号，直接加载驱动（系统自动分配）：  
   ```bash
   insmod chrdev.ko
   ```  
2. 查看分配的主/次设备号（内核日志会打印），并验证注册成功：  
   ```bash
   cat /proc/devices  # 应存在 "achrdev"
   ```  
3. 卸载驱动，验证设备号释放：  
   ```bash
   rmmod chrdev
   cat /proc/devices  # "achrdev" 应消失
   ```  
## 注册字符类设备

在Linux内核中，字符设备通过`cdev`结构体描述，其定义如下：  
```c
struct cdev {
    struct kobject kobj;          // 内核对象
    struct module *owner;         // 模块所有者（通常为THIS_MODULE）
    const struct file_operations *ops;  // 文件操作集（设备接口函数）
    struct list_head list;        // 链表节点
    dev_t dev;                    // 设备号（主设备号+次设备号）
    unsigned int count;           // 次设备号数量
};
```  
**设备号操作宏**  
`cdev`结构体中的`dev`（`dev_t`类型）包含主设备号（12位）和次设备号（20位），内核提供以下宏操作设备号：  
- `MAJOR(dev_t dev)`：从`dev_t`中提取主设备号  
- `MINOR(dev_t dev)`：从`dev_t`中提取次设备号  
- `MKDEV(int major, int minor)`：通过主、次设备号生成`dev_t`  

**操作`cdev`的核心函数**  
内核提供一组函数用于管理`cdev`结构体，实现字符设备的注册与注销：  
1. `void cdev_init(struct cdev *cdev, const struct file_operations *fops)`  
   - 参数说明：  
     - `cdev`：待初始化的`cdev`结构体；  
     - `fops`：文件操作集（`struct file_operations`类型）。  
   - 功能：初始化`cdev`的成员变量，核心是建立`cdev`与文件操作集的关联（即`cdev->ops = fops`）。 

2. `int cdev_add(struct cdev *cdev, dev_t dev, unsigned count)`  
   - 参数说明：  
     - `cdev`：已初始化的`cdev`结构体指针；  
     - `dev`：设备号（`dev_t`类型，包含主设备号和次设备号）；  
     - `count`：需要注册的次设备号数量。  
   - 功能：将字符设备添加到内核管理中，完成字符设备的注册（此时设备可被用户空间访问）,通常发生在字符设备驱动模块加载函数中 
    
3. `void cdev_del(struct cdev *cdev)`  
   - 参数说明：  
     - `cdev`：需要注销的`cdev`结构体指针。  
   - 功能：从内核中移除字符设备，完成字符设备的注销（释放内核资源）,通常发生在字符设备驱动模块卸载函数中。

**生成设备节点**  
字符设备注册后不会自动生成设备节点，需通过`mknod`命令手动创建，格式如下：  
```bash
mknod 设备节点路径 类型 主设备号 次设备号
```  
- 示例：`mknod /dev/test c 247 0`  
  （创建`/dev/test`设备节点，类型为字符设备（`c`），主设备号247，次设备号0）  


**编写字符设备驱动**    

```c
#include <linux/init.h>       // 初始化头文件
#include <linux/module.h>     // 模块基础支持
#include <linux/fs.h>         // 文件操作结构体定义
#include <linux/kdev_t.h>     // 设备号操作宏
#include <linux/cdev.h>       // cdev结构体及操作函数

#define DEVICE_NUMBER       1               // 次设备号数量
#define DEVICE_SNAME        "schrdev"       // 静态注册设备名称
#define DEVICE_ANAME        "achrdev"       // 动态注册设备名称
#define DEVICE_MINOR_NUMBER 0               // 次设备号起始值

static int major_num, minor_num;            // 主/次设备号（模块参数传入）
struct cdev cdev;                           // 定义cdev结构体

// 模块参数：允许加载时传入主/次设备号
module_param(major_num, int, S_IRUSR);
module_param(minor_num, int, S_IRUSR);

// 设备打开函数（用户层调用open时执行）
int chrdev_open(struct inode *inode, struct file *file) {
    printk("chrdev_open\n");
    return 0;
}

// 定义文件操作集（关联open函数）
struct file_operations chrdev_ops = {
    .owner = THIS_MODULE,  // 模块所有者
    .open = chrdev_open    // 关联打开函数
};

// 模块初始化函数（insmod时执行）
static int hello_init(void) {
    dev_t dev_num;  // 设备号
    int ret;        // 函数返回值

    if (major_num) {
        // 静态注册设备号
        printk("major_num = %d\n", major_num);
        printk("minor_num = %d\n", minor_num);
        dev_num = MKDEV(major_num, minor_num);  // 合并主/次设备号
        ret = register_chrdev_region(dev_num, DEVICE_NUMBER, DEVICE_SNAME);
        if (ret < 0) {
            printk("register_chrdev_region error\n");
            return ret;
        }
        printk("register_chrdev_region ok\n");
    } else {
        // 动态注册设备号
        ret = alloc_chrdev_region(&dev_num, DEVICE_MINOR_NUMBER, DEVICE_NUMBER, DEVICE_ANAME);
        if (ret < 0) {
            printk("alloc_chrdev_region error\n");
            return ret;
        }
        printk("alloc_chrdev_region ok\n");
        // 提取分配的主/次设备号
        major_num = MAJOR(dev_num);
        minor_num = MINOR(dev_num);
        printk("major_num = %d\n", major_num);
        printk("minor_num = %d\n", minor_num);
    }

    // 初始化cdev并关联文件操作集
    //对指针地址进行赋值而不是对指针地址所指向的内容，因此owner不用解引用
    cdev.owner = THIS_MODULE;
    cdev_init(&cdev, &chrdev_ops);

    // 注册字符设备到内核
    cdev_add(&cdev, dev_num, DEVICE_NUMBER);

    return 0;
}

// 模块退出函数（rmmod时执行）
static void hello_exit(void) {
    // 注销设备号和字符设备
    unregister_chrdev_region(MKDEV(major_num, minor_num), DEVICE_NUMBER);
    cdev_del(&cdev);  
    printk("goodbye! \n");
}

module_init(hello_init);   // 模块入口
module_exit(hello_exit);   // 模块出口
MODULE_LICENSE("GPL");     // 声明许可证
```  

**编写应用层测试程序**  
编写`app.c`用于测试字符设备是否注册成功，代码如下：  

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    int fd;
    char buf[64] = {0};

    // 打开设备节点（需提前创建）
    fd = open("/dev/test", O_RDWR);
    if (fd < 0) {
        perror("open error");
        return fd;
    }

    // 可添加read/write操作（此处仅测试打开）
    // read(fd, buf, sizeof(buf));

    close(fd);  // 关闭设备
    return 0;
}
```  

使用交叉编译器编译（确保适配开发板架构）：  
```bash
arm-none-linux-gnueabi-gcc app.c -o app -static  # 生成可在i.MX6ULL上运行的app
```  
 
**编译驱动模块**  
编写`Makefile`编译驱动：  
```makefile
obj-m += chrdev.o  # 生成的中间文件名（对应驱动源码chrdev.c）
KDIR := /home/topeet/driver/imx6ull/linux-imx-rel_imx_4.1.15_2.1.0_ga/  # 内核源码路径
PWD ?= $(shell pwd)  # 当前目录路径

all:
    make -C $(KDIR) M=$(PWD) modules  # 编译模块
```  
执行`make`生成`chrdev.ko`驱动模块。  

**测试步骤**  
1. **加载驱动模块**：  
   通过NFS将`chrdev.ko`和`app`传输到开发板，加载驱动：  
   ```bash
   cd /mnt/nfs/imx6ull/13chrdev/  # 进入共享目录
   insmod chrdev.ko  # 动态分配设备号（无需传入major_num）
   ```  
   内核日志会打印分配的主/次设备号（例如：主设备号248，次设备号0）。  
2. **创建设备节点**：  
   根据打印的设备号，用`mknod`创建节点：  
   ```bash
   mknod /dev/test c 248 0  # 类型为字符设备（c），主设备号248，次设备号0
   ```  
3. **运行应用程序**：  
   执行`app`测试设备是否可打开：  
   ```bash
   ./app
   ```  
   若应用程序无报错，且内核日志打印`chrdev_open`（驱动中`open`函数的输出），说明字符设备注册成功。  

**总结**  
注册字符设备的核心流程为：  
1. 分配/注册设备号（静态`register_chrdev_region`或动态`alloc_chrdev_region`）；  
2. 初始化`cdev`结构体并关联`file_operations`；  
3. 通过`cdev_add`注册字符设备到内核；  
4. 手动创建设备节点（`mknod`）；  
5. 卸载时通过`cdev_del`和`unregister_chrdev_region`释放资源。  
## 生成设备节点

**简介**  
在之前的字符设备驱动实验中，加载模块后需手动通过 `mknod` 命令创建设备节点，操作繁琐。Linux 系统通过 `mdev`（嵌入式系统常用，`udev` 的简化版）实现设备节点的自动创建与删除：当加载驱动模块时，`mdev` 会根据内核信息在 `/dev` 目录下自动生成设备文件，卸载模块时自动删除。  


### 创建和删除类的函数
内核通过 `struct class` 结构体描述一个“类”，类信息存储在 `/sys/class/` 目录下。创建类后，`mdev` 可通过类信息自动创建设备节点。  

#### 创建类：`class_create`  
`class_create` 是一个宏，用于创建类，定义如下：  
```c
#define class_create(owner, name) \
({ \
    static struct lock_class_key __key; \
    __class_create(owner, name, &__key); \
})

// 实际调用的函数
struct class *__class_create(struct module *owner, const char *name, struct lock_class_key *key)
```  
- 参数：  
  - `owner`：通常为 `THIS_MODULE`（当前驱动模块）；  
  - `name`：类的名称（将显示在 `/sys/class/` 目录下）。  
- 返回值：成功返回指向 `struct class` 的指针（创建的类），失败返回 `NULL` 或错误指针。  


#### 删除类：`class_destroy`  
卸载驱动时需删除创建的类，函数原型：  
```c
void class_destroy(struct class *cls);
```  
- 参数：`cls` 为要删除的类（`class_create` 的返回值）。  


### 创建设备的函数  
#### 创建设备：`device_create`
类创建后，需通过 `device_create` 在类下创建设备，从而触发 `mdev` 在 `/dev` 目录下生成设备节点。  

```c
struct device *device_create(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...);
```  
- 参数：  
  - `class`：设备所属的类（`class_create` 创建的类）；  
  - `parent`：父设备，通常为 `NULL`；  
  - `devt`：设备号（`dev_t` 类型）；  
  - `drvdata`：设备私有数据，通常为 `NULL`；  
  - `fmt`：设备名称（格式化字符串，如 `"chrdev_test"` 会生成 `/dev/chrdev_test`）。  
- 返回值：成功返回指向 `struct device` 的指针（创建的设备），失败返回 `NULL` 或错误指针。  


#### 删除设备：`device_destroy`  
卸载驱动时需删除创建的设备  
```c
void device_destroy(struct class *class, dev_t devt);
```  
- 参数：  
  - `class`：设备所属的类；  
  - `devt`：设备号（与 `device_create` 中的 `devt` 一致）。  


**创建设备的驱动程序** 

```c

#include <linux/init.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/kdev_t.h>
#include <linux/cdev.h>
#include <linux/device.h>

#define DEVICE_NUMBER       1
#define DEVICE_SNAME        "schrdev"
#define DEVICE_ANAME        "achrdev"
#define DEVICE_MINOR_NUMBER 0
#define DEVICE_CLASS_NAME   "chrdev_class"
#define DEVICE_NODE_NAME    "chrdev_test"  // 设备节点名称（/dev/chrdev_test）

static int major_num, minor_num;
struct class *class;         // 类
struct device *device;       // 设备
struct cdev cdev;
dev_t dev_num;

module_param(major_num, int, S_IRUSR);
module_param(minor_num, int, S_IRUSR);

// 设备打开函数
int chrdev_open(struct inode *inode, struct file *file) {
    printk("chrdev_open\n");
    return 0;
}

// 文件操作集
struct file_operations chrdev_ops = {
    .owner = THIS_MODULE,
    .open = chrdev_open
};

// 模块初始化函数
static int hello_init(void) {
    int ret;

    // 注册设备号（静态/动态）
    if (major_num) {
        dev_num = MKDEV(major_num, minor_num);
        ret = register_chrdev_region(dev_num, DEVICE_NUMBER, DEVICE_SNAME);
        if (ret < 0) {
            printk("register_chrdev_region error\n");
            return ret;
        }
    } else {
        ret = alloc_chrdev_region(&dev_num, DEVICE_MINOR_NUMBER, DEVICE_NUMBER, DEVICE_ANAME);
        if (ret < 0) {
            printk("alloc_chrdev_region error\n");
            return ret;
        }
        major_num = MAJOR(dev_num);
        minor_num = MINOR(dev_num);
    }
    printk("major_num = %d, minor_num = %d\n", major_num, minor_num);

    // 初始化并注册cdev
    cdev.owner = THIS_MODULE;
    cdev_init(&cdev, &chrdev_ops);
    cdev_add(&cdev, dev_num, DEVICE_NUMBER);

    // 创建类
    class = class_create(THIS_MODULE, DEVICE_CLASS_NAME);
    if (IS_ERR(class)) {
        printk("class_create error\n");
        return PTR_ERR(class);
    }

    // 创建设备（关键步骤）
    device = device_create(class, NULL, dev_num, NULL, DEVICE_NODE_NAME);
    if (IS_ERR(device)) {  // 检查设备创建是否失败
        printk("device_create error\n");
        class_destroy(class);  // 失败时需删除已创建的类
        return PTR_ERR(device);
    }

    return 0;
}

// 模块退出函数
static void hello_exit(void) {
    // 注销设备号、删除cdev
    unregister_chrdev_region(MKDEV(major_num, minor_num), DEVICE_NUMBER);
    cdev_del(&cdev);

    // 删除设备和类
    device_destroy(class, dev_num);
    class_destroy(class);

    printk("goodbye! \n");  
}

module_init(hello_init);
module_exit(hello_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("topeet");
```  


**应用测试程序**  

编写 `app.c` 验证设备节点是否可访问：  
```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    int fd;
    char buf[64] = {0};

    // 打开自动创建的设备节点 /dev/chrdev_test
    fd = open("/dev/chrdev_test", O_RDWR);
    if (fd < 0) {
        perror("open error");
        return fd;
    }

    // 可添加读写操作（此处仅测试打开）
    // read(fd, buf, sizeof(buf));

    close(fd);
    return 0;
}
```  

**编译应用程序**  
使用交叉编译器编译：  
```bash
arm-none-linux-gnueabi-gcc app.c -o app -static  # 生成开发板可执行文件
```  
**编译驱动模块**  
执行 `make` 生成 `chrdev.ko`。  

**测试设备节点自动创建**  
- 加载驱动模块：  
  ```bash
  insmod chrdev.ko
  ```  
- 验证类和设备节点：  
  ```bash
  # 查看类是否存在
  ls /sys/class/chrdev_class/
  
  # 查看设备节点是否自动创建（/dev/chrdev_test）
  ls /dev/chrdev_test
  ```  
- 运行应用程序测试：  
  ```bash
  ./app  # 若无报错，且内核日志打印"chrdev_open"，说明设备节点可用
  ```  
- 卸载模块（设备节点会自动删除）：  
  ```bash
  rmmod chrdev
  ls /dev/chrdev_test  # 此时应无此文件
  ```  
**总结**  
自动创建设备节点的核心流程：  
1. 注册设备号（静态/动态）；  
2. 初始化并注册 `cdev` 结构体；  
3. 用 `class_create` 创建类（在 `/sys/class/` 生成类目录）；  
4. 用 `device_create` 在类下创建设备（触发 `mdev` 在 `/dev` 生成设备节点）；  
5. 卸载时按相反顺序释放资源：`device_destroy` → `class_destroy` → `cdev_del` → 注销设备号。  
