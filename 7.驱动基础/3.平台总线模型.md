## Platform总线模型
Linux 设备驱动模型中，**总线**负责绑定设备与驱动：设备注册时寻找匹配的驱动，驱动注册时寻找匹配的设备。  

对于不依附于 PCI、USB 等物理总线的嵌入式外设（如 SoC 集成的控制器），Linux 引入 **Platform 虚拟总线**，对应：  
- `platform_device`：描述设备信息；  
- `platform_driver`：实现驱动逻辑；  
- `platform_bus`：负责设备与驱动的匹配。  

**核心优势**：将设备代码（`device.c`）与驱动代码（`driver.c`）分离，硬件相关信息放在 `device.c`，通用逻辑放在 `driver.c`，提高代码复用性，减少重复开发。  


### 一、Platform 设备  
#### platform_device结构体
`platform_device` 结构体描述设备信息（非设备树场景，有设备树则使用设备树），定义于 `include/linux/platform_device.h`：  
```c
struct platform_device {
    const char *name;               // 设备名（用于匹配驱动）
    int id;                         // 设备 ID（同名设备区分）
    bool id_auto;
    struct device dev;              // 内置设备结构体
    u32 num_resources;              // 资源数量
    struct resource *resource;      // 资源描述数组（寄存器、中断等）
    const struct platform_device_id *id_entry;  // 匹配用 ID 表
    ...
};
```  

**资源描述数组（`struct resource`）**  
设备的硬件资源（如寄存器地址、中断号）用 `resource` 结构体表示，定义于 `include/linux/ioport.h`：  
```c
struct resource {
    resource_size_t start;  // 资源起始地址（如寄存器起始地址）
    resource_size_t end;    // 资源结束地址
    const char *name;       // 资源名称
    unsigned long flags;    // 资源类型（如 IORESOURCE_MEM 表示内存）
    ...
};
```  
`struct resource`常用 `flags` 类型：  
- `IORESOURCE_IO`：I/O 端口；  
- `IORESOURCE_MEM`：物理内存（如寄存器）；  
- `IORESOURCE_IRQ`：中断号。  


**设备注册与注销**
pdev是指向platform_device结构体的指针
- 注册：`int platform_device_register(struct platform_device *pdev)`；  
- 注销：`void platform_device_unregister(struct platform_device *pdev)`。  

**Ps**：支持设备树的内核中，设备信息由设备树描述，无需手动定义 `platform_device`。  


### 二、Platform 驱动
#### `platform_driver` 结构体  
`platform_driver` 结构体定义驱动逻辑，定义于 `include/linux/platform_device.h`：  
```c
struct platform_driver {
    //函数指针，参数为platform_device*，返回值为int
    //这些参数指向的都是设备结构体
    int (*probe)(struct platform_device *);    // 设备与驱动匹配成功后执行
    int (*remove)(struct platform_device *);   // 设备或驱动卸载时执行
    void (*shutdown)(struct platform_device *); // 设备关机时执行
    int (*suspend)(struct platform_device *, pm_message_t state); // 设备挂起时执行
    int (*resume)(struct platform_device *);   // 设备恢复时执行
    struct device_driver driver;               // 内置驱动结构体
    const struct platform_device_id *id_table; // 支持的设备 ID 表
    ...
};
``` 
- 当 id_table 不为空时：内核只使用 id_table 进行匹配，完全不考虑 driver.name（即使 id_table 中没有匹配项，也 不会 fallback 到 driver.name）。
- 当 id_table 为空时：内核才会使用 driver.name 进行匹配。 
**关键成员**  
- `driver.name`：驱动名（用于匹配设备）；  
- `id_table`：驱动支持的设备列表（优先级高于 `driver.name`）；  
- `driver.of_match_table`：设备树匹配表（`compatible` 属性匹配）。  



**`device_driver` 结构体**
`device_driver` 结构体定义在 include/linux/device.h 内容如下：  
```c
struct device_driver {
const char *name;//匹配设备时用到的名字
struct bus_type *bus;
struct module *owner;
const struct of_device_id *of_match_table;
...
};
``` 



**`platform_driver` 结构体**
`platform_device_id` 结构体（`id_table` 元素类型）：  
```c
struct platform_device_id {
    char name[PLATFORM_NAME_SIZE];  // 支持的设备名
    kernel_ulong_t driver_data;     // 驱动私有数据
};
```  

**驱动注册与注销**  
- 注册：`int platform_driver_register(struct platform_driver *driver)`；  
- 注销：`void platform_driver_unregister(struct platform_driver *drv)`。  


### 三、Platform 总线  
Platform 总线是 `bus_type` 的实例，负责设备与驱动的匹配，定义于 `drivers/base/platform.c`：  
```c
struct bus_type platform_bus_type = {
    .name = "platform",
    .match = platform_match,  // 匹配函数
    ...
};
```  

**匹配逻辑（`platform_match`）**  
设备与驱动的匹配通过 `platform_match` 函数实现，优先级如下：  
1. **设备树匹配**：比较设备节点的 `compatible` 属性与驱动 `of_match_table` 中的 `compatible` 字段；  
2. **ACPI 匹配**：基于 ACPI 表信息匹配；  
3. **ID 表匹配**：比较设备名与驱动 `id_table` 中的 `name` 字段；  
4. **名称匹配**：直接比较设备 `name` 与驱动 `driver.name`。  


#### probe 函数编写思路  
`probe` 函数在设备与驱动匹配成功后执行，核心流程：  
1. **获取硬件资源**：从 `platform_device` 中提取资源（寄存器地址、中断等）
**1）直接获取**
- 不推荐，不安全
`int beep_probe(struct platform_device *pdev)`函数的参数`pdev`指向平台设备结构体，包含硬件信息
因此可以访问硬件资源，如
```c
//访问struct platform_device结构体的成员结构体变量struct resource中的硬件信息name
pdev->resource[0].name
```

**使用 `platform_get_resource`函数获取**  
- 推荐，安全
   ```c
   struct resource *platform_get_resource(struct platform_device *pdev,unsigned int type, unsigned int num);
   ``` 
   - `pdev`：指向平台设备结构体的指针 
   - `type`：资源类型（如 `IORESOURCE_MEM`）；  
   - `num`：同类资源的索引，填resource数组的索引是不对的，一定要同类型，但是从0开始排序
**返回值**
-成功返回资源结构体指针，失败返回NULL  

2. **注册设备**：在 `probe` 中注册字符设备/杂项设备，实现 `file_operations` 接口，生成设备节点。  


#### I/O 内存申请  
操作硬件前需通过 `request_mem_region` 声明占用的内存区域（避免冲突）：  
```c
#include <linux/ioport.h>
struct resource *request_mem_region(resource_size_t start, size_t n, const char *name);
```  
- `start`：内存起始地址；  
- `n`：内存长度；  
- `name`：资源名称。  


### 蜂鸣器 Platform 驱动  
以 imx6ull 开发板的蜂鸣器为例，实现 Platform 驱动（设备与驱动分离）。  


**编写 device.c（设备）**  
蜂鸣器控制引脚为 `SNVS_TAMPER1`（复用为 `GPIO5_01`），其数据寄存器地址为 `0x020AC000`。  

```c

#include <linux/init.h>
#include <linux/module.h>
#include <linux/platform_device.h>

// 设备释放函数
void beep_release(struct device *dev) {
    printk("beep_release \n");
}

// 蜂鸣器硬件资源（寄存器地址）
struct resource beep_res[] = {
    [0] = {
        .start = 0x020AC000,  // GPIO5_01 数据寄存器起始地址
        .end = 0x020AC003,    // 寄存器结束地址（32位寄存器）
        .flags = IORESOURCE_MEM,  // 资源类型：内存
        .name = "GPIO5_DR"    // 资源名称
    }
};

// 平台设备结构体
struct platform_device beep_device = {
    .name = "beep_test",                // 设备名（用于匹配驱动）
    .id = -1,                           // 单设备无需 ID
    .resource = beep_res,               // 关联资源
    .num_resources = ARRAY_SIZE(beep_res),  // 资源数量
    .dev = {
    .release = beep_release         // 设备释放回调
    }
};

// 模块初始化：注册平台设备
static int device_init(void) {
    platform_device_register(&beep_device);
    printk("platform_device_register ok \n");
    return 0;
}

// 模块退出：注销平台设备
static void device_exit(void) {
    platform_device_unregister(&beep_device);
    printk("goodbye! \n");  
}

module_init(device_init);
module_exit(device_exit);
MODULE_LICENSE("GPL");
```  


**编译与测试**  
1. **Makefile**：  
   ```makefile
   obj-m += device.o
   KDIR := /home/topeet/driver/imx6ull/linux-imx-rel_imx_4.1.15_2.1.0_ga/
   PWD ?= $(shell pwd)
   all:
       make -C $(KDIR) M=$(PWD) modules
   ```  

2. **测试**：  
   加载模块后，查看 `/sys/bus/platform/devices/` 目录是否出现 `beep_test` 设备：  
   ```bash
   insmod device.ko
   ls /sys/bus/platform/devices/  # 应显示 beep_test
   ```  


**编写 driver.c（驱动）**  
驱动与设备匹配成功后，通过 `probe` 函数初始化硬件并注册设备节点。  

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/ioport.h>
#include <linux/miscdevice.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/io.h>

#define BEEP_DEV_NAME "hello_misc"
unsigned int *vir_gpio5_dr;  // GPIO5数据寄存器虚拟地址
struct resource *beep_mem;   // 硬件资源（物理地址等）
int ret;

// 写操作：接收用户指令控制蜂鸣器
ssize_t misc_write(struct file *file, const char __user *ubuf, 
                  size_t size, loff_t *loff) {
    char kbuf[64] = {0};
    if (copy_from_user(kbuf, ubuf, size)) {
        printk("copy_from_user error\n");
        return -EFAULT;
    }

    // 控制GPIO5_01引脚（bit1）：1-响，0-灭
    if (kbuf[0] == 1)
    //或操作
        *vir_gpio5_dr |= (1 << 1);  // 置位bit1（高电平）
    else if (kbuf[0] == 0)
    //与操作
        *vir_gpio5_dr &= ~(1 << 1); // 清零bit1（低电平）

    return size;
}

// 文件操作集
struct file_operations misc_fops = {
    .owner = THIS_MODULE,
    .write = misc_write,
};

// 杂项设备注册
struct miscdevice misc_dev = {
    .minor = MISC_DYNAMIC_MINOR,
    .name = BEEP_DEV_NAME,
    .fops = &misc_fops,
};

// 驱动与设备匹配成功后执行：初始化硬件
int beep_probe(struct platform_device *pdev) {
    printk("beep_probe: 匹配成功\n");

    // 获取GPIO5_DR寄存器物理地址资源
    beep_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    if (!beep_mem) {
        printk("获取硬件资源失败\n");
        return -EBUSY;
    }
    printk("物理地址: 0x%x - 0x%x\n", beep_mem->start, beep_mem->end);

    // 物理地址映射到虚拟地址（32位寄存器，长度4字节）
    vir_gpio5_dr = ioremap(beep_mem->start, 4);
    if (!vir_gpio5_dr) {
        printk("地址映射失败\n");
        return -EBUSY;
    }

    // 注册杂项设备（创建设备节点）
    ret = misc_register(&misc_dev);
    if (ret < 0) {
        printk("杂项设备注册失败\n");
        iounmap(vir_gpio5_dr);
        return ret;
    }
    printk("设备节点 /dev/%s 已创建\n", BEEP_DEV_NAME);
    return 0;
}

// 设备/驱动卸载时执行：释放资源
int beep_remove(struct platform_device *pdev) {
    printk("beep_remove: 释放资源\n");
    misc_deregister(&misc_dev);  // 注销杂项设备
    iounmap(vir_gpio5_dr);       // 解除地址映射
    return 0;
}

// 设备ID表（匹配优先级高于driver.name）
const struct platform_device_id beep_idtable = {
    .name = "beep_test"
};

// 平台驱动结构体
struct platform_driver beep_driver = {
    .probe = beep_probe,
    .remove = beep_remove,
    .driver = { .owner = THIS_MODULE, .name = "beep_test" },
    .id_table = &beep_idtable
};

// 模块初始化：注册平台驱动
static int beep_driver_init(void) {
    ret = platform_driver_register(&beep_driver);
    if (ret < 0) {
        printk("驱动注册失败\n");
        return ret;
    }
    printk("驱动注册成功\n");
    return 0;
}

// 模块退出：注销平台驱动
static void beep_driver_exit(void) {
    platform_driver_unregister(&beep_driver);
    printk("驱动已注销\n");
}

module_init(beep_driver_init);
module_exit(beep_driver_exit);
MODULE_LICENSE("GPL");
```  


**编译与测试**  
1. **Makefile**：  
```makefile
obj-m += driver.o  # 生成的模块名为driver.ko
KDIR := /home/topeet/driver/imx6ull/linux-imx-rel_imx_4.1.15_2.1.0_ga/  # 内核源码路径
PWD ?= $(shell pwd)  # 当前目录路径
all:
    make -C $(KDIR) M=$(PWD) modules  # 调用内核Makefile编译模块

clean:
    make -C $(KDIR) M=$(PWD) clean  # 清理编译产物
``` 

2. **测试匹配逻辑**：  
   - 先加载 `device.ko`，再加载 `driver.ko`，内核日志应打印 `beep_probe`（匹配成功）；  
   - 若修改 `id_table.name` 与设备名不一致，匹配失败，`probe` 不执行。  




**应用测试程序（app.c）**  
```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    int fd;
    char buf[1] = {0};
    if (argc != 2) {
        printf("Usage: %s <0|1>\n", argv[0]);
        return -1;
    }
    fd = open("/dev/hello_misc", O_RDWR);
    if (fd < 0) {
        perror("open error");
        return fd;
    }
    buf[0] = atoi(argv[1]);  // 输入 1 蜂鸣器响，0 灭
    write(fd, buf, 1);
    close(fd);
    return 0;
}
```  

**编译与测试**  
1. **编译应用**：  
   ```bash
   arm-none-linux-gnueabi-gcc app.c -o app -static
   ```  

2. **测试流程**：  
   ```bash
   # 加载设备与驱动
   insmod device.ko
   insmod driver.ko
   # 查看设备节点
   ls /dev/hello_misc
   # 控制蜂鸣器
   ./app 1  # 蜂鸣器响
   ./app 0  # 蜂鸣器灭
   ```  

**总结**  
Platform 驱动模型通过“设备-总线-驱动”分离架构，将硬件信息与驱动逻辑解耦，显著提高代码复用性和可移植性。核心步骤：  
1. 设备端（`device.c`）：定义硬件资源（寄存器、中断等）并注册；  
2. 驱动端（`driver.c`）：实现 `probe` 函数（获取资源、注册设备节点）并注册；  
  
