## 杂项设备驱动(misc)
**本质**：一类特殊的字符设备驱动，内核自动分配主设备号，只需申请次设备号

- 需包含以下头文件
```c
#include <linux/miscdevice.h>  
#include <linux/fs.h>
```



#### 三、开发核心步骤：如何编写一个基础杂项设备驱动？
杂项设备驱动的开发流程固定，核心是填充`miscdevice`结构体并注册
- 注册杂项设备
- 定义杂项设备结构体(miscdevice)
- 实现文件操作集结构体(file_operations)
- 注销杂项设备


1. **定义杂项设备结构体**  
   结构体需指定设备名称（`name`，将作为`/dev`下的节点名）、文件操作集合（`fops`，关联读写/控制硬件的函数）、次设备号（`minor`，设为`MISC_DYNAMIC_MINOR`表示自动分配）。
   ```c
   static struct miscdevice my_miscdev = {
       .minor = MISC_DYNAMIC_MINOR,  // 自动分配次设备号
       .name = "my_misc_device",     // /dev下的设备节点名
       .fops = &my_fops,             // 关联文件操作函数
   };
   ```

2. **实现文件操作函数**  
   定义`file_operations`结构体，实现硬件的核心操作（如`open`打开设备、`ioctl`控制硬件、`release`释放设备），例如控制LED亮灭的`ioctl`函数。
   ```c
   // 关联文件操作函数
   static const struct file_operations my_fops = {
       .owner = THIS_MODULE,
       .unlocked_ioctl = my_ioctl,
   };

   static long my_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
       switch(cmd) {
           case LED_ON:  // 自定义命令：LED亮
               gpio_set_value(LED_GPIO, 1);
               break;
           case LED_OFF: // 自定义命令：LED灭
               gpio_set_value(LED_GPIO, 0);
               break;
       }
       return 0;
   }

   ```

3. **注册与注销杂项设备**  
   在驱动初始化函数（`init`）中调用`misc_register()`注册设备，在退出函数（`exit`）中调用`misc_deregister()`注销，完成驱动的加载与卸载。
   ```c
   static int __init my_misc_init(void) {
       return misc_register(&my_miscdev);  // 注册杂项设备
   }
   static void __exit my_misc_exit(void) {
       misc_deregister(&my_miscdev);      // 注销杂项设备
   }
   module_init(my_misc_init);  // 指定驱动初始化入口
   module_exit(my_misc_exit);  // 指定驱动退出入口
   ```

4. **编译与测试**  
   通过Makefile编译为内核模块（`.ko`文件），加载模块后，内核会自动在`/dev`目录生成`/dev/my_misc_device`节点，用户态程序可通过`open`/`ioctl`等系统调用操作硬件。
