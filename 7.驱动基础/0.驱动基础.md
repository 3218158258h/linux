

## 驱动模块编译
### 基本结构
```c
#include <linux/init.h>   // 包含模块初始化相关函数
#include <linux/module.h> // 包含模块核心定义

// 模块加载时执行的函数（入口函数）
static int __init hello_init(void)
{
    printk(KERN_INFO "Hello, Linux Driver!\n"); // 内核打印（类似printf，用于内核态）
    return 0; // 返回0表示初始化成功
}

// 模块卸载时执行的函数（出口函数）
static void __exit hello_exit(void)
{
    printk(KERN_INFO "Goodbye, Linux Driver!\n");
}

// 注册入口函数（当insmod加载模块时调用）
module_init(hello_init);
// 注册出口函数（当rmmod卸载模块时调用）
module_exit(hello_exit);

// 模块描述信息（可选，但推荐添加）
MODULE_LICENSE("GPL");          // 声明开源协议（必须，否则内核会报警告）
MODULE_AUTHOR("Your Name");     // 作者信息
MODULE_DESCRIPTION("A Simple Linux Driver"); // 模块功能描述
```


### 核心结构解析
1. **头文件**  
   - `linux/init.h`：提供 `module_init`、`module_exit` 等初始化相关宏。  
   - `linux/module.h`：提供模块基本定义（如 `MODULE_LICENSE`）和内核API（如 `printk`）。

2. **入口函数（`hello_init`）**  
   - 被 `__init` 修饰：内核会在模块加载后释放该函数占用的内存（仅初始化时用一次）。  
   - 功能：驱动加载时的初始化操作（如申请资源、注册设备等，这里仅打印信息）。  
   - 返回值：`0` 表示成功，非0表示失败（模块加载失败）。

3. **出口函数（`hello_exit`）**  
   - 被 `__exit` 修饰：仅用于模块卸载时调用，内核会对其做特殊处理。  
   - 功能：驱动卸载时的清理操作（如释放资源、注销设备等，这里仅打印信息）。

4. **模块注册宏**  
   - `module_init(hello_init)`：告诉内核“当模块加载时，调用 `hello_init`”。  
   - `module_exit(hello_exit)`：告诉内核“当模块卸载时，调用 `hello_exit`”。

5. **模块信息宏**  
   - `MODULE_LICENSE("GPL")`：必须声明，否则内核加载时会提示“模块未遵循GPL协议”的警告，且可能导致部分内核功能不可用（如与其他GPL模块交互）。  
   - 其他宏（`MODULE_AUTHOR` 等）：可选，用于描述模块信息，可通过 `modinfo` 命令查看。


### 编译成驱动模块
- 1.编译后然后放入drivers目录（体积大，拖累启动系统速度）
- 2.编译成.ko文件，即内核模块，独立于内核，在需要的时候加载，不需要的时候卸载
**注意**
- 编译驱动时调用的内核源码一定要编译过(这样才会生成编译驱动所需的各种文件如.config)
- 同时这个内核源码也要和开发板上的系统是同一套，以防模块调用的函数等错误
`编译方法`:内核模块
**配置环境**
- `export ARCH=arm `和`export CROSS_COMPILE=arm-linux-gnueabihf- `


使用Makefile编译
```makefile
# 指定内核源码路径（需替换为你的内核源码目录）
KERNELDIR := /home/topeet/linux-kernel
# 当前目录路径
PWD := $(shell pwd)

# 编译模块
obj-m := hello_drv.o  # 生成的模块名为 hello_drv.ko

# 调用内核Makefile编译
# 进入KERNELDIR目录，使用PWD目录的源码和Makefile文件编译驱动模块
all:
    make -C $(KERNELDIR) M=$(PWD) modules

# 清理编译产物
clean:
    rm -f *.o *.mod.o *.mod.c  *.symvers *.order
```

```bash
make  # 生成 hello_drv.ko
```
**加载模块**
把驱动模块复制到开发板后执行以下命令
`insmod xxxxxx.ko`
**查看模块**
`lsmod`
**卸载模块**
`rmmod xxxxxx.ko`


### 编译进内核
##############################################################################################################################

## make menuconfig图形化配置
make menuconfig 是 Linux 内核提供的一种字符界面的图形化配置工具，用于可视化地选择内核支持的功能、硬件驱动、特性等，最终生成内核编译所需的 .config 配置文件。


### 一、使用前提
1. **已安装必要工具**：`menuconfig` 依赖 ncurses 库（提供字符界面交互支持）

2. **已进入内核源码目录**：`menuconfig` 必须在内核源码根目录执行（需先 `cd /path/to/linux-kernel`）。

3. **已设置交叉编译环境**（嵌入式场景）：若编译嵌入式内核（如 ARM），需先设置 `ARCH` 和 `CROSS_COMPILE` 环境变量（否则默认按本机架构配置）：  
   ```bash
   export ARCH=arm
   export CROSS_COMPILE=arm-linux-gnueabihf-
   ```


### 二、启动 `menuconfig`
在内核源码目录执行：
```bash
make menuconfig
```


### 三、界面操作说明
**搜索**
- 输入`/`进入搜索功能

**配置项类型及操作**
内核配置项主要有 4 种类型，通过前缀标识，操作方式不同：
- 使用空格配置不同状态
| 前缀 | 类型说明                                                                 | 操作（按空格键切换）                  |
|------|--------------------------------------------------------------------------|---------------------------------------|
| `[*]` | 布尔型（Bool）：功能开关，选中表示开启（编译到内核）。                   | `[*]`（开启） ↔ `[ ]`（关闭）         |
| `<*>` | 三态型（Tristate）：可选择“内置”“模块”“关闭”（驱动常用）。              | `<*>`（内置） ↔ `<M>`（模块） ↔ `< >`（关闭） |
| `(x)` | 字符串/数值型：需填写具体值（如端口号、缓冲区大小）。                   | 按 Enter 键输入值                     |
| `---` | 依赖项：当前项依赖的其他配置未开启，无法修改（灰色显示）。               | 需先开启依赖项才能配置                |

- **内置（<*> 或 [*]）**：功能被编译到内核镜像中，随内核启动加载，无法卸载。  
- **模块（<M>）**：功能被编译为独立 `.ko` 文件，可动态加载/卸载（驱动常用）。  


**保存与加载配置**
- **保存配置**：选择底部 `<Save>` 按钮，按 Enter 确认保存路径（默认 `./.config`），生成的 `.config` 即为内核编译的配置文件。  
- **加载配置**：若已有现成的 `.config` 文件（如厂商提供的默认配置），选择 `<Load>` 按钮，输入文件路径加载（无需重新逐项配置）。  
- **恢复默认**：若想重置为默认配置，可先删除现有 `.config`，再执行 `make defconfig`（加载当前架构的默认配置），然后重新 `make menuconfig`。  

## file_operations结构体（文件操作集）
在 Linux 内核驱动开发中，`static const struct file_operations my_fops` 是字符设备驱动的核心结构体定义，用于将用户空间的文件操作（如 `open`、`read`、`write` 等）映射到驱动中具体的实现函数，是内核与驱动交互的关键接口。

- **`my_fops`**：结构体实例名，可自定义（通常以 `fops` 结尾标识“文件操作集”）。


**核心成员及作用：**
`struct file_operations` 的成员均为函数指针，常用成员及对应功能如下：

| 成员名               | 对应用户空间调用 | 作用描述                                                                 |
|----------------------|------------------|--------------------------------------------------------------------------|
| `.owner`             | -                | 通常设为 `THIS_MODULE`，用于内核管理模块引用计数（防止模块被意外卸载）。 |
| `.open`              | `open()`         | 打开设备文件时触发，用于初始化设备、分配资源（如锁、缓冲区）。           |
| `.release`           | `close()`        | 关闭设备文件时触发，用于释放资源（如释放锁、回收缓冲区）。               |
| `.read`              | `read()`         | 从设备读取数据到用户空间（需处理内核空间与用户空间的数据拷贝）。         |
| `.write`             | `write()`        | 将用户空间数据写入设备（同样需处理数据拷贝）。                           |
| `.unlocked_ioctl`    | `ioctl()`        | 处理用户空间的控制命令（如设备配置、状态查询），非阻塞版本。             |
| `.llseek`            | `lseek()`        | 调整文件读写指针位置（用于随机访问设备）。                               |
| `.mmap`              | `mmap()`         | 将设备内存映射到用户空间，允许用户直接访问硬件地址（减少拷贝开销）。     |


**常见成员及含义**
结构体的成员是一系列函数指针，常用的包括：
```c
struct file_operations {
    struct module *owner;          // 指向模块自身，通常设为 THIS_MODULE，用于模块计数管理
    loff_t (*llseek) (struct file *, loff_t, int);  // 定位文件指针（类似 lseek）
    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);  // 读设备（用户空间 -> 内核）
    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);  // 写设备（内核 -> 用户空间）
    int (*open) (struct inode *, struct file *);    // 打开设备
    int (*release) (struct inode *, struct file *); // 关闭设备（释放资源）
    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);  // 无锁 IO 控制（用户空间发命令）
    unsigned int (*poll) (struct file *, struct poll_table_struct *);  // 轮询（用于异步 IO，如 select/poll/epoll）
    // 其他成员（如 mmap、fasync 等，根据需求实现）
};
```



**示例用法**
在字符设备驱动中，通常会定义一个 `file_operations` 实例，并在注册设备时关联到设备号：
```c
#include <linux/fs.h>
#include <linux/module.h>

// 实现具体的操作函数
static int mydev_open(struct inode *inode, struct file *file) {
    printk("Device opened\n");
    return 0;
}

static ssize_t mydev_read(struct file *file, char __user *buf, size_t count, loff_t *pos) {
    // 从内核缓冲区拷贝数据到用户空间（需用 copy_to_user）
    printk("Reading from device\n");
    return 0;
}

// 定义 file_operations 结构体
static const struct file_operations mydev_fops = {
    .owner = THIS_MODULE,  // 必须设置，防止模块被意外卸载
    .open = mydev_open,
    .read = mydev_read,
    // 其他需要的操作（如 write、release 等）
};

// 驱动初始化时注册字符设备（简化示例）
static int __init mydev_init(void) {
    register_chrdev(0, "mydevice", &mydev_fops);  // 0 表示动态分配设备号
    return 0;
}

module_init(mydev_init);
MODULE_LICENSE("GPL");
```




**示例初始化：**
```c
#include <linux/fs.h>  // 包含 file_operations 定义

// 驱动实现的具体操作函数（需提前声明）
static int my_open(struct inode *inode, struct file *file);
static ssize_t my_read(struct file *file, char __user *buf, size_t count, loff_t *pos);
static ssize_t my_write(struct file *file, const char __user *buf, size_t count, loff_t *pos);
static int my_release(struct inode *inode, struct file *file);

// 定义文件操作集
static const struct file_operations my_fops = {
    .owner = THIS_MODULE,    // 绑定到当前模块
    .open = my_open,         // 关联 open 操作的实现，调用open函数时会执行my_open函数
    .read = my_read,         // 关联 read 操作的实现，调用read函数时会执行my_read函数
    .write = my_write,       // 关联 write 操作的实现，调用write函数时会执行my_write函数
    .release = my_release,   // 关联 close 操作的实现，调用close函数时会执行my_release函数
    // 其他未初始化的成员默认为 NULL（内核调用时会检查，未实现则返回错误）
};
```
通过file_operations，应用层和内核实现了数据交互

**Ubuntu中的读写函数**
```c
struct file_operations {
    struct module *owner;  // 模块所有者，通常为 THIS_MODULE

    // 读操作函数指针：用户调用 read() 时触发
    ssize_t (*read)(struct file *file, char __user *buf, size_t count, loff_t *pos);

    // 写操作函数指针：用户调用 write() 时触发
    ssize_t (*write)(struct file *file, const char __user *buf, size_t count, loff_t *pos);

    // 其他操作（省略部分成员）
    int (*open)(struct inode *inode, struct file *file);
    int (*release)(struct inode *inode, struct file *file);
    loff_t (*llseek)(struct file *file, loff_t offset, int whence);
    long (*unlocked_ioctl)(struct file *file, unsigned int cmd, unsigned long arg);
    int (*mmap)(struct file *file, struct vm_area_struct *vma);
    // ... 其他成员
};
```

########################################################################################################

## 内核的函数
**copy_to_user**
`copy_to_user` 是 Linux 内核中用于将**内核空间数据拷贝到用户空间**的核心函数，是驱动开发中（尤其是 `read` 操作）的关键工具。由于 Linux 内核严格隔离内核空间与用户空间（两者地址空间独立，直接访问会导致内存越界或崩溃），必须通过这类专用函数完成数据交互。
**核心作用**
当驱动需要向用户空间返回数据（例如 `my_read` 函数中，用户调用 `read` 读取设备数据）时，不能直接通过指针赋值（如 `*buf = kernel_data`），而必须使用 `copy_to_user`：它会先检查用户空间指针的合法性（避免访问无效地址），再安全地完成数据拷贝。
**函数原型**
定义在 `include/linux/uaccess.h` 头文件中，原型如下：
```c
unsigned long copy_to_user(void __user *to, const void *from, unsigned long n);
```
**参数说明：**
- `to`：用户空间的缓冲区指针（即用户程序调用 `read` 时传入的 `buf` 参数，需用 `__user` 修饰标识其来自用户空间）。
- `from`：内核空间的数据指针（驱动中存储待读取数据的缓冲区）。
- `n`：需要拷贝的字节数。

**返回值：**
- 成功：返回 `0`（表示所有 `n` 字节都已成功拷贝到用户空间）。
- 失败：返回**未成功拷贝的字节数**（非0值，通常表示用户空间指针无效或权限不足）。
**典型用法（结合 `my_read`）**
在驱动的 `read` 实现中，`copy_to_user` 是核心步骤，示例如下：
```c
#include <linux/uaccess.h>  // 包含 copy_to_user 定义

static ssize_t my_read(struct file *file, char __user *buf, size_t count, loff_t *pos) {
    char kernel_buf[1024] = "hello from kernel";  // 内核空间的数据
    ssize_t ret = 0;
    size_t data_len = strlen(kernel_buf) + 1;  // 数据长度（包含结束符）

    // 限制拷贝长度：不超过内核数据实际长度，也不超过用户请求的 count
    if (count > data_len) {
        count = data_len;
    }

    // 拷贝内核数据到用户空间
    ret = copy_to_user(buf, kernel_buf, count);
    if (ret != 0) {
        // 拷贝失败：返回错误码 -EFAULT（表示用户空间地址错误）
        return -EFAULT;
    }

    // 拷贝成功：返回实际拷贝的字节数
    *pos += count;  // 更新文件读写位置
    return count;
}
```

##############################################################################################################

**copy_from_user**  
`copy_from_user` 是 Linux 内核中用于将**用户空间数据拷贝到内核空间**的核心函数，是驱动开发中（尤其是 `write` 操作）的关键工具。由于 Linux 内核严格隔离内核空间与用户空间（两者地址空间独立，直接访问会导致内存越界或崩溃），必须通过这类专用函数完成数据交互。  


**核心作用**  
当驱动需要接收用户空间传入的数据（例如 `my_write` 函数中，用户调用 `write` 向设备写入数据）时，不能直接通过指针赋值（如 `kernel_data = *buf`），而必须使用 `copy_from_user`：它会先检查用户空间指针的合法性（避免访问无效地址），再安全地完成数据拷贝。  


**函数原型**  
定义在 `include/linux/uaccess.h` 头文件中，原型如下：  
```c
unsigned long copy_from_user(void *to, const void __user *from, unsigned long n);
```  


**参数说明：**  
- `to`：内核空间的缓冲区指针（驱动中用于存储接收数据的缓冲区）。  
- `from`：用户空间的数据源指针（即用户程序调用 `write` 时传入的 `buf` 参数，需用 `__user` 修饰标识其来自用户空间）。  
- `n`：需要拷贝的字节数。  


**返回值：**  
- 成功：返回 `0`（表示所有 `n` 字节都已成功拷贝到内核空间）。  
- 失败：返回**未成功拷贝的字节数**（非0值，通常表示用户空间指针无效或权限不足）。  


**典型用法（结合 `my_write`）**  
在驱动的 `write` 实现中，`copy_from_user` 是核心步骤，示例如下：  
```c
#include <linux/uaccess.h>  // 包含 copy_from_user 定义

static ssize_t my_write(struct file *file, const char __user *buf, size_t count, loff_t *pos) {
    char kernel_buf[1024];  // 内核空间的缓冲区（用于接收用户数据）
    ssize_t ret = 0;
    size_t max_len = sizeof(kernel_buf) - 1;  // 预留1字节存结束符

    // 限制拷贝长度：不超过内核缓冲区大小，也不超过用户传入的 count
    if (count > max_len) {
        count = max_len;
    }

    // 拷贝用户空间数据到内核空间
    ret = copy_from_user(kernel_buf, buf, count);
    if (ret != 0) {
        // 拷贝失败：返回错误码 -EFAULT（表示用户空间地址错误）
        return -EFAULT;
    }

    // 给内核缓冲区添加结束符（可选，根据业务需求）
    kernel_buf[count] = '\0';

    // 此处可添加处理内核数据的逻辑（如写入硬件设备）
    printk(KERN_INFO "Received from user: %s\n", kernel_buf);

    // 拷贝成功：返回实际拷贝的字节数
    *pos += count;  // 更新文件读写位置
    return count;
}
```

#################################################################################################################

**ioremap**  
`ioremap` 是 Linux 内核中用于将**物理地址（如硬件寄存器地址、物理内存块）映射到内核虚拟地址**的核心函数，是驱动开发中访问硬件设备（如外设寄存器、物理内存缓冲区）的关键工具。

**核心作用**  
当驱动需要访问硬件设备的物理地址（例如：外设的控制寄存器、DMA 缓冲区的物理地址等）时，不能直接使用物理地址（内核虚拟地址空间与物理地址空间独立，直接访问会导致地址无效或崩溃），而必须通过 `ioremap` 将物理地址映射为内核可访问的虚拟地址。映射后，驱动可通过该虚拟地址读写对应的物理内存或硬件寄存器。  

**函数原型**  
定义在 `include/asm/io.h` 头文件中（不同架构的实现可能略有差异，但接口一致），原型如下：  
```c
void __iomem *ioremap(resource_size_t phys_addr, size_t size);
```  

**参数说明：**  
- `phys_addr`：需要映射的物理起始地址（必须是内核可访问的物理地址，如硬件手册中定义的寄存器物理基地址、通过 `platform_get_resource` 获取的设备资源地址等）。  
- `size`：需要映射的内存长度（字节数），用于指定从 `phys_addr` 开始的连续物理地址范围。  

**返回值：**  
- 成功：返回映射后的**内核虚拟地址**（类型为 `void __iomem *`，`__iomem` 修饰符用于标记该地址为 I/O 内存映射地址，帮助静态代码检查工具识别）。  
- 失败：返回 `NULL`（通常因物理地址无效、权限不足或映射范围越界导致）。  


**典型用法（访问硬件寄存器）**  
在驱动中访问外设寄存器时，`ioremap` 是必经步骤，示例如下：  
```c
#include <asm/io.h>  // 包含 ioremap 定义

// 假设硬件手册中定义：UART 控制器的寄存器物理基地址为 0x12340000，共 8 个寄存器（32 字节）
#define UART_PHYS_BASE 0x12340000
#define UART_REG_SIZE  32  // 映射 32 字节（覆盖所有寄存器）

static void __iomem *uart_virt_base;  // 存储映射后的虚拟地址

// 驱动初始化时映射物理地址
static int my_driver_init(void) {
    // 映射 UART 寄存器的物理地址到内核虚拟地址
    uart_virt_base = ioremap(UART_PHYS_BASE, UART_REG_SIZE);
    if (!uart_virt_base) {
        printk(KERN_ERR "Failed to ioremap UART registers\n");
        return -ENOMEM;  // 映射失败，返回内存不足错误
    }

    // 映射成功后，通过虚拟地址访问寄存器（通常用 readl/writel 等函数，保证跨架构兼容性）
    uint32_t status = readl(uart_virt_base + 0x04);  // 读偏移 0x04 的状态寄存器
    printk(KERN_INFO "UART status: 0x%x\n", status);

    return 0;
}

// 驱动退出时解映射（必须调用，避免内存泄漏）
static void my_driver_exit(void) {
    if (uart_virt_base) {
        iounmap(uart_virt_base);  // 释放映射
        uart_virt_base = NULL;
    }
}

module_init(my_driver_init);
module_exit(my_driver_exit);
```  


**关键注意事项**  
1. **必须解映射**：映射的虚拟地址使用完毕后（如驱动卸载时），必须通过 `iounmap` 函数释放映射（`void iounmap(void __iomem *addr)`），否则会导致内核地址空间泄漏。  
2. **访问方式**：映射后的 I/O 内存虚拟地址，应使用内核提供的专用函数访问（如 `readb/readw/readl` 读操作，`writeb/writew/writel` 写操作），而非直接指针解引用（`*addr`），以适配不同架构的内存对齐、缓存策略（如某些硬件需要禁用缓存）。  

#####################################################################################################################
**iounmap**  
`iounmap` 是 Linux 内核中用于**解除由 `ioremap` 建立的物理地址到内核虚拟地址映射**的函数，是驱动开发中资源释放的关键工具。由于 `ioremap` 会占用内核虚拟地址空间，若映射后不释放，会导致地址空间泄漏，长期运行可能引发系统稳定性问题，因此 `iounmap` 必须与 `ioremap` 配对使用。  

**函数原型**  
定义在 `include/asm/io.h` 头文件中（与 `ioremap` 同路径），原型如下：  
```c
void iounmap(void __iomem *addr);
```  
- `addr`：需要解除映射的内核虚拟地址（必须是之前通过 `ioremap`、`ioremap_nocache` 等函数返回的有效地址，且带有 `__iomem` 修饰符）。  
- 无返回值（`void`）

**关键注意事项**  
1. **配对使用**：`iounmap` 必须与 `ioremap` 严格配对——每调用一次 `ioremap` 成功，就必须在驱动生命周期结束时（如卸载）调用一次 `iounmap`，否则会导致内核虚拟地址空间泄漏。   
2. **禁止重复调用**：对同一虚拟地址重复调用 `iounmap` 是危险的，可能导致内核页表损坏（第一次调用已释放映射，第二次调用会操作无效页表）。  



 
## 驱动传参

- 内核模块中，`inmod 模块名 参数名=参数`
- 模块内置，通过 bootloader 在 `bootargs` 中`模块名.参数名=值`

```
inmod beep.ko a=1
```

**作用**
- 设置驱动参数，如缓冲区的大小
- 设置安全校验，防止驱动被盗用


**驱动传参的方法** 

1. 传递普通参数（如 char、int 类型）  
使用函数 `module_param(name, type, perm)`，参数说明：  
- `name`：传递的参数名称（模块内定义的变量名）  
- `type`：参数类型（如 int、charp 等）  
- `perm`：参数的读写权限（用于 `/sys/module/模块名/parameters/` 下的文件权限）  


2. 常用参数权限宏定义
| 宏定义       | 权限解释                          |
|--------------|-----------------------------------|
| `S_IRUSR`    | 00400，文件所有者可读             |
| `S_IWUSR`    | 00200，文件所有者可写             |
| `S_IXUSR`    | 00100，文件所有者可执行           |
| `S_IRGRP`    | 00040，与所有者同组用户可读       |
| `S_IWGRP`    | 00020，与所有者同组用户可写       |
| `S_IXGRP`    | 00010，与所有者同组用户可执行     |
| `S_IROTH`    | 00004，其他用户可读               |
| `S_IWOTH`    | 00002，其他用户可写               |
| `S_IXOTH`    | 00001，其他用户可执行             |

**权限判断方法**：  
将权限数值最后三位转为二进制（`xxx xxx xxx`），从高位到低位依次对应：  
- 前三位：文件所有者的读/写/执行权限  
- 中间三位：同组用户的读/写/执行权限  
- 后三位：其他用户的读/写/执行权限  


3. 传递数组参数  
使用函数 `module_param_array(name, type, nump, perm)`，参数说明：  
- `name`：数组名称（模块内定义的数组变量）  
- `type`：数组元素类型（如 int）  
- `nump`：用于保存实际传入的元素个数（模块内定义的整型变量）  
- `perm`：参数的读写权限  




**驱动程序编写**   
在 `parameter.c` 中实现传递普通参数的逻辑：  
```c
#include <linux/init.h>
#include <linux/module.h>

// 定义待传递的整型变量 a
static int a;
// 注册参数 a：类型为 int，权限为所有者可读（S_IRUSR）
module_param(a, int, S_IRUSR);

static int hello_init(void) {
    // 打印参数 a 的值
    printk("a = %d \n", a);
    printk("hello world! \n");
    return 0;
}

static void hello_exit(void) {
    // 退出时再次打印参数 a 的值
    printk("a = %d \n", a);
    printk("goodbye! \n");
}

module_init(hello_init);   // 模块入口
module_exit(hello_exit);   // 模块出口
MODULE_LICENSE("GPL");     // 声明许可证
```


**编译配置（Makefile）**
```makefile
obj-m += parameter.o  # 生成的中间文件名
KDIR := /home/topeet/driver/imx6ull/linux-imx-rel_imx_4.1.15_2.1.0_ga/  # 内核源码路径
PWD ?= $(shell pwd)  # 当前目录路径

all:
    make -C $(KDIR) M=$(PWD) modules  # 进入内核源码目录编译模块
```
**测试步骤**  
1. 编译驱动：执行 `make` 生成 `parameter.ko`  
2. 加载模块（无参数，使用默认值）：  
   ```bash
   insmod parameter.ko
   ```  
   此时 `a` 未赋值，默认值为 0，内核日志会打印 `a = 0`。  

3. 卸载模块后重新传递参数：  
   ```bash
   rmmod parameter
   insmod parameter.ko a=5  # 传递参数 a=5
   ```  
   内核日志会打印 `a = 5`。  



**驱动模块传数组**  
```c
#include <linux/init.h>
#include <linux/module.h>

// 定义数组 b（大小为 5）
static int b[5];
// 定义变量 count 用于保存实际传入的元素个数
static int count;

// 注册数组参数 b：类型为 int，实际个数存于 count，权限为所有者可读
module_param_array(b, int, &count, S_IRUSR);

static int hello_init(void) {
    int i;
    // 遍历打印数组元素
    for (i = 0; i < count; i++) {
        printk("b[%d] = %d \n", i, b[i]);
    }
    // 打印实际传入的元素个数
    printk("count = %d \n", count);
    return 0;
}

static void hello_exit(void) {
    printk("goodbye! \n");
}

module_init(hello_init);
module_exit(hello_exit);
MODULE_LICENSE("GPL");
```


### 测试步骤  
1. 编译驱动：执行 `make` 生成 `parameter.ko`  
2. 加载模块并传递数组参数：  
   ```bash
   insmod parameter.ko b=1,2,3,4,5  # 传递 5 个元素（与数组大小一致）
   ```  
   内核日志会打印：  
   ```
   b[0] = 1 
   b[1] = 2 
   b[2] = 3 
   b[3] = 4 
   b[4] = 5 
   count = 5 
   ```  

3. 测试数组越界情况：  
   传递超过数组大小的元素（如 6 个）：  
   ```bash
   rmmod parameter
   insmod parameter.ko b=1,2,3,4,5,6  # 传递 6 个元素
   ```  
   内核会自动截断，只保留前 5 个元素，日志打印 `count = 5`。  



