#### `signal`（信号处理函数）
`signal` 是 Unix/Linux 系统中用于注册**信号处理函数**的基础接口，用于定义进程在接收到特定信号时应执行的操作，是实现进程间异步通信和异常处理的核心函数。
```c
#include <signal.h>
typedef void (*sighandler_t)(int); // 信号处理函数类型定义
sighandler_t signal(int signum, sighandler_t handler);
```
### 核心参数与返回值
- **`signum`**：要处理的信号编号（如 `SIGINT` 对应 Ctrl+C、`SIGTERM` 对应终止信号）。
- **`handler`**：信号触发时执行的处理函数，可选值有 3 种：
  1. 自定义函数指针（如 `void my_handler(int sig)`），用于执行自定义逻辑。
  2. `SIG_IGN`：忽略该信号（信号触发后进程无任何反应）。
  3. `SIG_DFL`：恢复该信号的**默认处理行为**（如 `SIGINT` 默认终止进程）。
- **返回值**：成功返回之前注册的信号处理函数；失败返回 `SIG_ERR` 并设置 `errno`。


### 常见信号与默认行为
| 信号编号 | 信号名   | 触发场景                  | 默认行为       |
|----------|----------|---------------------------|----------------|
| 2        | `SIGINT` | 按下 Ctrl+C               | 终止进程       |
| 15       | `SIGTERM`| `kill` 命令默认发送        | 终止进程（可捕获）|
| 9        | `SIGKILL`| `kill -9` 强制终止        | 强制终止（不可捕获）|
| 11       | `SIGSEGV`| 内存访问错误（如空指针）  | 终止并生成核心转储 |
### 基础示例：捕获 Ctrl+C 信号
下面代码通过 `signal` 注册自定义处理函数，使进程接收到 `SIGINT`（Ctrl+C）时不终止，而是打印提示信息：
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
// 自定义信号处理函数
void handle_sigint(int sig) {
    printf("\n捕获到信号 %d（Ctrl+C），进程不终止！\n", sig);
}
int main() {
    // 注册 SIGINT 信号的处理函数
    if (signal(SIGINT, handle_sigint) == SIG_ERR) {
        perror("signal 注册失败");
        return 1;
    }
    printf("程序运行中，按下 Ctrl+C 测试信号处理（输入 Ctrl+\\ 强制退出）...\n");
    while (1) {
        sleep(1); // 循环等待信号
    }
    return 0;
}
```
**运行结果**：
```
程序运行中，按下 Ctrl+C 测试信号处理（输入 Ctrl+\ 强制退出）...
^C
捕获到信号 2（Ctrl+C），进程不终止！
^C
捕获到信号 2（Ctrl+C），进程不终止！
```
### 关键注意事项
1. **不可捕获的信号**：`SIGKILL`（9）和 `SIGSTOP`（19）无法通过 `signal` 注册处理函数，只能执行默认行为（强制终止/暂停），用于紧急控制进程。
2. **信号处理函数的安全性**：处理函数内应使用**可重入函数**（如 `write`、`snprintf`），避免调用 `malloc`、`printf` 等不可重入函数，防止程序异常。
3. **与 `sigaction` 的区别**：`signal` 是早期接口，行为在不同系统中可能不一致；`sigaction` 是更标准、功能更全的替代接口（支持信号掩码、获取信号信息），推荐在复杂场景使用。
4. **信号的“一次生效”问题**：部分系统中，自定义处理函数执行后，信号处理方式会自动恢复为 `SIG_DFL`，需在处理函数内重新注册以支持多次捕获。

