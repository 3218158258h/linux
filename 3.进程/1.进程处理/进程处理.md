#### `system` 基本用法
```c
#include <stdlib.h>
int system(const char *command);
```
1. `command`：指向字符串的指针，该字符串为要在系统shell中执行的命令（如 `ls -l`、`cmd /c dir`）；若为 `NULL`，则仅检查系统是否支持shell。

#### 返回值
- 成功：返回命令执行后的退出状态（需通过 `WIFEXITED`、`WEXITSTATUS` 等宏解析具体状态）
- 失败（如无法创建子进程、找不到shell）：返回 `-1`
- 若 `command` 为 `NULL`：支持shell返回非0值，不支持返回0

```c
#include <stdlib.h>
#include <stdio.h>
#include <sys/wait.h> // 用于解析返回状态的宏

int main() {
    // 执行系统命令 "ls -l"（Linux/macOS）或 "dir"（Windows）
    int status = system("ls -l");
    
    if (status == -1) {
        perror("system 调用失败");
        return 1;
    }
    
    // 解析命令执行结果
    if (WIFEXITED(status)) {
        printf("命令正常退出，退出码：%d\n", WEXITSTATUS(status));
    } else {
        printf("命令异常终止\n");
    }
    
    return 0;
}
```
- **本质**：通过创建子进程调用系统shell（如 `/bin/sh`），由shell执行指定命令，父进程阻塞等待命令完成。

`======================================================================`

`======================================================================`
#### `fork` 基本介绍
`fork()` 是 **Linux 系统中创建新进程的核心系统调用**，通过“复制当前进程”的方式生成一个新进程（子进程），父子进程共享代码段，但拥有独立的数据段、堆栈和进程ID（PID）。
其函数原型如下（需包含头文件 `<unistd.h>`）：
```c
#include <unistd.h>
pid_t fork(void);
```
#### 核心特性：“一次调用，两次返回”
`fork()` 的特殊之处在于，**调用一次会返回两次**，通过返回值区分父子进程：
- **在父进程中**：返回 **子进程的PID**（一个大于0的整数），用于后续管理子进程（如通过 `wait()` 等待子进程结束）。
- **在子进程中**：返回 **0**，表示自身是新创建的子进程。
- **失败**：返回 **-1**（如系统资源不足、进程数达到上限），且不会创建子进程。
#### 基础示例：通过返回值区分在父/子进程中
```c
#include <unistd.h>
#include <stdio.h>
#include <sys/wait.h> // 用于 wait() 函数

int main() {
    pid_t pid = fork(); // 创建子进程，从此时开始已经有两个进程，后面的代码在两个进程同时运行

    if (pid == -1) {
        perror("fork 失败");  
        return 1;
    } 
    // 子进程逻辑（返回值为0）
    else if (pid == 0) {
        printf("我是子进程，我的PID：%d，父进程PID：%d\n", getpid(), getppid());
        // 子进程执行任务（例：休眠2秒）
        sleep(2);
        printf("子进程执行完毕\n");
    } 
    // 父进程逻辑（返回值为子进程PID）
    else {
        printf("我是父进程，我的PID：%d，子进程PID：%d\n", getpid(), pid);
        // 父进程等待子进程结束，避免子进程成为僵尸进程
        wait(NULL); 
        printf("父进程：子进程已结束\n");
    }

    return 0;
}
```
**输出结果**（PID为示例值，实际会变化）：
```
我是父进程，我的PID：1234，子进程PID：1235
我是子进程，我的PID：1235，父进程PID：1234
子进程执行完毕
父进程：子进程已结束
```
#### 关键概念与注意事项
1. **父子进程的资源共享与独立**
   - **共享**：代码段（执行的指令）、打开的文件描述符（如已打开的文件、网络连接）。
   - **独立**：数据段（全局变量、静态变量）、堆栈（局部变量、函数调用栈）——子进程会复制父进程的这些数据，后续修改互不影响。
2. **僵尸进程（Zombie）问题**
   - 子进程结束后，会保留退出状态等信息，等待父进程通过 `wait()` 或 `waitpid()` 回收。
   - 若父进程未回收且未先退出，子进程会成为“僵尸进程”（状态为 `Z`，可通过 `ps aux` 查看），占用系统PID资源。
   - **解决方式**：父进程主动调用 `wait()`（等待任意子进程）或 `waitpid(pid, &status, 0)`（等待指定PID的子进程）。

`======================================================================`

`======================================================================`
#### `getpid` 基本介绍
`getpid()` 是 **Linux 系统中获取`当前进程`ID（PID）的系统调用**，每个运行中的进程都有唯一的PID，该函数可直接返回当前进程的标识ID，常用于进程管理、日志记录等场景。
```c
#include <unistd.h>
pid_t getpid(void);
```
- 返回值：`pid_t` 类型（本质是整数），代表当前进程的唯一PID。
- 特点：无参数，调用不会失败（只要进程正常运行，就一定有合法PID）。

#### 核心用途与示例
`getpid()` 最常见的场景是**区分进程身份**，尤其在 `fork()` 创建子进程后，结合 `getpid()` 和 `getppid()`（获取父进程PID）可清晰标识父子进程。

##### 基础示例：获取当前进程PID
```c
#include <unistd.h>
#include <stdio.h>
int main() {
    // 获取并打印当前进程（main进程）的PID
    printf("当前进程的PID：%d\n", getpid());
    return 0;
}
```
**输出结果**（PID为系统分配的随机整数，示例值）：
```
当前进程的PID：4567
```

`======================================================================`

`======================================================================`
#### `getppid` 基本介绍
`getppid()` 是 **Linux 系统中获取当前进程“父进程ID（PPID）”的系统调用**，用于定位当前进程的“父进程”（即创建当前进程的进程），与 `getpid()`（获取自身PID）配合使用，可清晰梳理进程间的父子关系。
```c
#include <unistd.h>
pid_t getppid(void);
```
- 返回值：`pid_t` 类型（本质是整数），代表当前进程父进程的唯一PID。
- 特点：无参数，正常运行时不会失败；若父进程已退出，返回值会变为系统“收养进程”的PID（通常是 `1`，即 `init` 或 `systemd` 进程）。
#### 核心用途与示例
`getppid()` 最核心的作用是**确认父进程身份**，尤其在 `fork()` 创建子进程后，子进程可通过它获取父进程PID，或判断父进程是否已退出。
##### 父进程退出后，子进程被“收养”
若父进程先于子进程退出，子进程会成为“孤儿进程”，并被系统进程（如 `init`，PID=1）收养，此时 `getppid()` 返回 `1`：
```c
#include <unistd.h>
#include <stdio.h>
int main() {
    pid_t fork_pid = fork();
    if (fork_pid == 0) {
        printf("子进程初始 - 父进程PID：%d\n", getppid());
        sleep(2); // 等待父进程先退出
        printf("子进程后续 - 父进程PID：%d（已被系统收养）\n", getppid());
    } else if (fork_pid > 0) {
        printf("父进程（PID：%d）即将退出\n", getpid());
        // 父进程不等待子进程，直接退出
    }
    return 0;
}
```
**输出结果**（示例值）：
```
父进程（PID：7890）即将退出
子进程初始 - 父进程PID：7890
子进程后续 - 父进程PID：1（已被系统收养）
```

`======================================================================`

`======================================================================`
#### `sleep` 基本介绍
`sleep()` 是 **Linux 系统中让当前进程暂停执行指定时间的函数**，单位为“秒”，暂停期间进程会进入“可中断睡眠状态（S状态）”，不占用CPU资源，直到睡眠时间结束或被信号中断。

```c
#include <unistd.h>
unsigned int sleep(unsigned int seconds);
```
- **参数**：`seconds`，指定进程要暂停的秒数（无符号整数）。
- **返回值**：
  - 成功：返回 `0`（表示完整休眠了指定的 `seconds` 秒）。
  - 被信号中断：返回**剩余未休眠的秒数**（例如休眠5秒时被中断，返回3表示还剩3秒未休眠）。

##### 简单延时
让进程暂停2秒后再继续执行：
```c
#include <unistd.h>
#include <stdio.h>

int main() {
    printf("程序开始，即将休眠2秒...\n");
    
    unsigned int remain = sleep(2); // 休眠2秒
    
    if (remain == 0) {
        printf("休眠完成，程序继续执行\n");
    } else {
        printf("休眠被中断，剩余未休眠时间：%u 秒\n", remain);
    }
    
    return 0;
}
```
**输出结果**（无中断时）：
```
程序开始，即将休眠2秒...
（暂停2秒）
休眠完成，程序继续执行
```


`======================================================================`

`======================================================================`
`execve` 是 **用于加载并执行新程序的核心系统调用**，它会替换当前进程的代码段、数据段和堆栈，仅保留进程ID（PID）等核心属性，
是实现进程程序替换的关键接口。简单来说，它会在当前进程中执行新的程序，但是保留该进程原来的pid等信息

```c
#include <unistd.h>
int execve(const char *pathname, char *const argv[], char *const envp[]);
```
- **核心参数说明**：
  - `pathname`：指向要执行的新程序的**完整路径或相对路径**（如 `/bin/ls`、`./a.out`），必须是可执行文件。
  - `argv`：字符串`数组`，存储新程序的**命令行参数**。格式要求：
    - 第一个元素 `argv[0]` 通常是程序名（与 `pathname` 关联，如 `ls`）；
    - 后续元素为具体参数（如 `-l`、`/home`）；
    - 数组末尾必须以 `NULL` 结尾（标记参数列表结束）。
    - 示例：`char *argv[] = {"linux/ls/lsd/abc/ddd","ls","-l","NULL"}；`//参数个数不定，可自行添加。
  - `envp`：字符串数组，存储新程序的**环境变量**（如 `PATH=/bin`、`USER=root`），同样需以 `NULL` 结尾；
    - 一般用`pathname`指定路径,因此可以填 `NULL`
- **返回值**：
  - 成功：**不返回**（因当前进程代码已被新程序替换，原代码不再执行）；
  - 失败：返回 `-1`（仅当新程序加载/执行出错时，如路径不存在、权限不足，才会返回错误）。
### 2. 核心用途与基础示例
`execve` 通常与 `fork()`（创建子进程）配合使用：父进程创建子进程后，子进程通过 `execve` 替换为新程序，父进程继续执行原有逻辑（避免自身被替换）。

#### 示例：子进程执行 `ls -l` 命令
```c
#include <unistd.h>
#include <stdio.h>
#include <sys/wait.h>
#include <stdlib.h>
int main() {
    pid_t pid = fork(); // 创建子进程
    if (pid == -1) {
        perror("fork failed"); // 子进程创建失败
        exit(1);
    } 
    else if (pid == 0) {
        // 子进程：执行 execve 替换为 ls -l
        char *const argv[] = {"ls", "-l", NULL}; // 参数列表（末尾NULL）
        char *const envp[] = {NULL}; // 环境变量（NULL表示继承父进程环境）

        // 执行 /bin/ls 程序，参数为 -l
        execve("/bin/ls", argv, envp);

        // 若 execve 返回，说明执行失败
        perror("execve failed"); 
        exit(1);
    } 
    else {
        // 父进程：等待子进程执行完成
        wait(NULL); 
        printf("子进程已执行完毕\n");
    }

    return 0;
}
```
**输出结果**：
```
total 8
-rwxr-xr-x 1 user user 5680 Aug 10 15:30 a.out
-rw-r--r-- 1 user user  680 Aug 10 15:29 test.c
子进程已执行完毕
```


### 3. 关键特性与注意事项
- **进程替换本质**：`execve` 不创建新进程，仅替换当前进程的“程序内容”，PID、PPID、打开的文件描述符等属性保持不变（打开的文件默认不关闭，除非设置了 `FD_CLOEXEC` 标志）。
- **错误处理**：必须检查 `execve` 的返回值——若返回，必然是错误（如 `pathname` 路径错误、文件无执行权限、参数列表未以 `NULL` 结尾等），需用 `perror()` 打印错误原因。
- **与库函数的区别**：`execve` 是系统调用，而 `execl`、`execv`、`execlp`、`execvp` 是封装它的库函数（如 `execvp` 会自动从 `PATH` 环境变量查找程序路径，无需写完整路径），核心功能一致，仅参数格式不同。
- **环境变量控制**：若 `envp` 非 `NULL`，新程序的环境变量完全由 `envp` 指定（不继承父进程）；若需自定义环境变量，需构造完整的 `envp` 数组（如 `char *envp[] = {"PATH=/usr/bin", "USER=test", NULL};`）。


`======================================================================`

`======================================================================`
### `waitpid`是用于父进程等待子进程结束的系统调用，比 `wait()` 更灵活，支持指定等待的子进程、控制阻塞行为等。##
```c
#include <sys/wait.h>
#include <sys/types.h>
pid_t waitpid(pid_t pid, int *wstatus, int options);
```
#### 核心参数说明
| 参数       | 含义与取值                                                                 |
|------------|----------------------------------------------------------------------------|
| `pid`      | 指定要等待的子进程PID，常用取值：<br>- **`-1`**：等待任意一个子进程（同 `wait()`）<br>- **`>0`**：等待PID等于该值的特定子进程<br>- **`0`**：等待与当前进程同属一个进程组的任意子进程<br>- **`< -1`**：等待进程组ID等于该值绝对值的任意子进程 |
| `wstatus`  | 指针，用于存储子进程的退出状态（如退出码、终止信号），可通过宏解析（见下文）；若为 `NULL`，表示不关心退出状态 |
| `options`  | 控制等待行为的选项，常用取值：<br>- **`0`**：默认阻塞模式（父进程暂停执行，直到子进程结束）<br>- **`WNOHANG`**：非阻塞模式（若子进程未结束，立即返回 `0`，不阻塞父进程）<br>- **`WUNTRACED`**：同时等待被暂停的子进程 |

#### 返回值
- **成功**：返回已结束/暂停的子进程PID；若 `options` 为 `WNOHANG` 且子进程未结束，返回 `0`。
- **失败**：返回 `-1`（如无可用子进程、被信号中断），并设置 `errno`。


### 2. 核心用途：解析子进程退出状态
`waitpid` 通过 `wstatus` 指针获取子进程的退出状态，需用系统提供的宏解析（直接操作 `wstatus` 可能出错），常用宏如下：

| 宏                | 作用                                                                 |
|-------------------|----------------------------------------------------------------------|
| `WIFEXITED(wstatus)`  | 判断子进程是否**正常退出**（如调用 `exit()` 或 `return`），是则返回非0值 |
| `WEXITSTATUS(wstatus)`| 若 `WIFEXITED` 为真，获取子进程的**正常退出码**（如 `exit(3)` 则返回3） |
| `WIFSIGNALED(wstatus)`| 判断子进程是否被**信号终止**（如 `kill -9`），是则返回非0值             |
| `WTERMSIG(wstatus)`  | 若 `WIFSIGNALED` 为真，获取终止子进程的**信号编号**（如9表示SIGKILL）   |


### 3. 基础示例（常见场景）
#### 场景1：阻塞等待指定子进程正常退出
父进程创建子进程后，阻塞等待该子进程结束，并获取其退出码：
```c
#include <sys/wait.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    pid_t pid = fork();
    if (pid == -1) {
        perror("fork failed");
        exit(1);
    }

    if (pid == 0) {
        // 子进程：正常退出，退出码为5
        printf("子进程（PID：%d）执行完毕，退出码5\n", getpid());
        exit(5); 
    } else {
        int wstatus;
        // 阻塞等待PID为pid的子进程（第三个参数0表示阻塞）
        pid_t wait_pid = waitpid(pid, &wstatus, 0);

        if (wait_pid == -1) {
            perror("waitpid failed");
            exit(1);
        }

        // 解析子进程退出状态
        if (WIFEXITED(wstatus)) {
            printf("父进程：子进程（PID：%d）正常退出，退出码：%d\n", 
                   wait_pid, WEXITSTATUS(wstatus));
        }
    }
    return 0;
}
```
**输出结果**：
```
子进程（PID：12345）执行完毕，退出码5
父进程：子进程（PID：12345）正常退出，退出码：5
```

#### 场景2：非阻塞轮询等待子进程
父进程不阻塞，定期检查子进程是否结束（用 `WNOHANG` 选项）：
```c
#include <sys/wait.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    pid_t pid = fork();
    if (pid == -1) {
        perror("fork failed");
        exit(1);
    }

    if (pid == 0) {
        // 子进程：休眠3秒后退出
        sleep(3);
        printf("子进程（PID：%d）结束\n", getpid());
        exit(0);
    } else {
        int wstatus;
        while (1) {
            // 非阻塞等待：子进程未结束则返回0，不阻塞
            pid_t wait_pid = waitpid(pid, &wstatus, WNOHANG);

            if (wait_pid == 0) {
                // 子进程未结束，父进程继续做其他事（这里模拟耗时操作）
                printf("父进程：子进程还在运行，继续等待...\n");
                sleep(1); // 每隔1秒检查一次
            } else if (wait_pid == pid) {
                // 子进程已结束，解析状态后退出循环
                if (WIFEXITED(wstatus)) {
                    printf("父进程：子进程（PID：%d）正常退出\n", wait_pid);
                }
                break;
            } else {
                perror("waitpid failed");
                break;
            }
        }
    }
    return 0;
}
```
**输出结果**：
```
父进程：子进程还在运行，继续等待...
父进程：子进程还在运行，继续等待...
父进程：子进程还在运行，继续等待...
子进程（PID：12345）结束
父进程：子进程（PID：12345）正常退出
```
