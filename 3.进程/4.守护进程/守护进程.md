#### 设置会话ID
`setsid()` 是 **创建新会话（session）并设置进程组 ID（PGID）的系统调用**，主要用于将进程与原有终端（tty）分离，创建一个独立于终端的后台进程（守护进程，daemon）。
```c
#include <unistd.h>
pid_t setsid(void);
```
#### 核心功能：创建新会话与进程组
`setsid()` 的核心作用是让调用进程脱离原有终端控制，具体表现为：
- **创建新会话**：调用进程成为新会话的首进程（session leader）。
- **创建新进程组**：调用进程成为新进程组的组长进程（process group leader），进程组 ID（PGID）等于进程自身 PID。
- **脱离终端**：调用进程不再关联任何控制终端（tty），即使原终端关闭，进程也不会收到 `SIGHUP` 信号而终止。

返回值说明：
- **成功**：返回新会话的首进程 PID（即调用进程自身 PID）。
- **失败**：返回 **-1**（若调用进程已是进程组组长，则调用失败，这也是 `fork()` 后通常在子进程中调用 `setsid()` 的原因）。

 **守护进程（Daemon）的典型流程**
   `setsid()` 是创建守护进程的关键步骤，完整流程通常包括：
   - `fork()` 后父进程退出，子进程成为孤儿进程。
   - 调用 `setsid()` 脱离终端，创建新会话。
   - （可选）再次 `fork()`，确保进程不是会话首进程，彻底避免获取终端。
   - 重置 `umask` 权限掩码。
   - 切换工作目录（如 `/`），避免占用可卸载的文件系统。
   - 重定向标准输入、输出、错误到 `/dev/null`，避免依赖终端。



#### 修改掩码
#### `umask` 基本介绍
`umask`（用户文件创建模式掩码）是 **用于限制新文件和目录默认权限的机制**，通过预设“禁止权限”来从系统默认的最大权限中“减去”相应权限，得到最终的实际权限。

```c
#include <sys/stat.h>
mode_t umask(mode_t mask);
```

`umask` 的核心逻辑是 **“从最大权限中减去掩码定义的禁止权限”**



#### 切换工作目录
#### `chdir` 基本介绍
`chdir`（change directory）是 **用于修改进程当前工作目录的系统调用**，它允许进程切换到指定的目录路径，类似于 Shell 中的 `cd` 命令，但作用于程序内部。

```c
#include <unistd.h>
int chdir(const char *path);
```
- `path` ：指向目录的字符串指针，`chdir("/invalid_directory")`
- 绝对或者相对路径都行
`chdir` 的主要作用是改变调用进程的当前工作目录，后续所有相对路径的操作（如文件创建、打开）都会基于新的工作目录进行。

返回值说明：
- **成功**：返回 `0`，表示工作目录已成功切换。
- **失败**：返回 `-1`，并设置 `errno` 表示错误原因

#### 开启日志
#### `openlog` 基本介绍
`openlog()` 是 **Linux 系统中用于初始化 syslog 日志系统连接的函数**，它可以指定日志的标识、选项和优先级，为后续调用 `syslog()` 函数发送日志做准备，避免每次调用 `syslog()` 时重复设置参数。

```c
#include <syslog.h>
void openlog(const char *ident, int option, int facility);
```
- **参数**：
  - `ident`：指向字符串的指针，该字符串会作为日志消息的标识前缀（通常为程序名称），后续所有 `syslog()` 调用都会包含此标识。若为 `NULL`，则使用程序的名称（`argv[0]`）。
  - `option`：日志操作选项，通过位或（`|`）组合多个选项，常见选项包括：
    - `LOG_PID`：在日志中包含进程 PID。
    - `LOG_CONS`：若日志无法发送到 syslog 守护进程，则直接写入控制台。
    - `LOG_NDELAY`：立即打开与 syslog 守护进程的连接（默认会延迟到首次 `syslog()` 调用时）。
    - `LOG_ODELAY`：延迟打开连接（默认行为）。
  - `facility`：指定日志的类型（用于分类日志），常见值包括：
    - `LOG_USER`：用户级别的日志（默认值）。
    - `LOG_DAEMON`：系统守护进程的日志（如后台服务）。
    - `LOG_AUTH`：认证相关的日志（如登录、权限验证）。
    - `LOG_LOCAL0` 至 `LOG_LOCAL7`：用户自定义的日志类型。
- **返回值**：无返回值（`void`）。



#### 输出日志
#### `syslog` 基本介绍
`syslog()` 是 **用于向系统日志服务发送日志消息的函数**，是应用程序与 syslog 系统交互的核心接口，可将程序运行时的事件、错误等信息写入系统日志（如 `/var/log/syslog`），便于集中管理和分析。

```c
#include <syslog.h>
void syslog(int priority, const char *format, ...);
```
- **参数**：
  - `priority`：日志的优先级与设备类型（`facility`）的组合，格式为 `facility | level`（若未通过 `openlog()` 指定 `facility`，默认使用 `LOG_USER`）。常见优先级（从高到低）：
    - `LOG_EMERG`：系统不可用（如内核崩溃）。
    - `LOG_ALERT`：需立即处理（如磁盘满）。
    - `LOG_CRIT`：严重错误（如硬件故障）。
    - `LOG_ERR`：普通错误（如函数调用失败）。
    - `LOG_WARNING`：警告信息（如资源不足）。
    - `LOG_NOTICE`：值得注意的正常事件（如用户登录）。
    - `LOG_INFO`：普通信息（如程序启动）。
    - `LOG_DEBUG`：调试信息（仅开发阶段使用）。
  - `format`：日志消息的格式字符串，遵循 `printf()` 风格（如 `"%s: 启动成功"`）。
  - `...`：可变参数，与 `format` 中的占位符对应（如字符串、数值等）。
- **返回值**：无返回值（`void`）。

#### 基础示例：发送不同级别日志
```c

    // 初始化日志（指定标识、选项和设备类型）
    openlog("myapp", LOG_PID | LOG_CONS, LOG_USER);
    
    // 发送不同优先级的日志
    syslog(LOG_INFO, "程序启动，版本 1.0");
    syslog(LOG_WARNING, "磁盘空间不足（剩余 10%%）");
    
    int error_code = -1;
    syslog(LOG_ERR, "文件打开失败，错误码：%d", error_code);
    
    // 关闭日志连接（可选，进程退出时会自动关闭）
    closelog();

```
```
Oct  7 15:30:00 ubuntu myapp[12345]: 程序启动，版本 1.0
Oct  7 15:30:00 ubuntu myapp[12345]: 磁盘空间不足（剩余 10%）
Oct  7 15:30:00 ubuntu myapp[12345]: 文件打开失败，错误码：-1
```



#### 关闭日志
#### `closelog` 基本介绍
`closelog()` 是 **Linux 系统中用于关闭与 syslog 日志系统连接的函数**，它与 `openlog()` 配套使用，用于释放 `openlog()` 初始化的日志资源，结束程序与 syslog 守护进程的交互。

```c
#include <syslog.h>
void closelog(void);
```
- **参数**：无参数。
- **返回值**：无返回值（`void`）。



#### 关闭文件
#### `sysconf` 基本介绍
`sysconf()` 是 **用于查询系统运行时配置参数的函数**，可获取内核、进程、内存、文件系统等方面的系统限制或特性值（如最大进程数、页大小、CPU核心数等），这些参数通常定义在 POSIX 标准中，确保程序在不同系统上的可移植性。

```c
#include <unistd.h>
long sysconf(int name);
```
- **参数**：`name`，指定要查询的系统配置参数，需传入预定义的宏（如 `_SC_PAGESIZE` 表示查询内存页大小），常见宏及含义见下文。
- **返回值**：
  - 成功：返回查询到的配置参数值（类型为 `long`）。
  - 失败：返回 `-1`，并设置 `errno`


#### 核心功能：获取系统配置与限制
`sysconf()` 的核心作用是从系统内核中读取动态配置或静态限制，避免程序硬编码这些参数（如直接写死“内存页大小为4096字节”），确保程序在不同硬件架构（如 x86_64、ARM）或系统版本上正常运行。

常见查询参数（`name` 取值）及含义：
| 参数宏                | 含义                                                                 |
|-----------------------|----------------------------------------------------------------------|
| `_SC_PAGESIZE`        | 系统内存页大小（字节），如 x86_64 系统通常为 4096                     |
| `_SC_NPROCESSORS_ONLN`| 当前在线的 CPU 核心数（逻辑核心）                                     |
| `_SC_CHILD_MAX`       | 单个进程可创建的最大子进程数                                         |
| `_SC_OPEN_MAX`        | 单个进程可同时打开的最大文件描述符数                                 |
| `_SC_CLK_TCK`         | 系统时钟滴答频率（每秒的时钟周期数，用于 `times()` 函数计算时间）     |
| `_SC_VERSION`         | 系统遵循的 POSIX 标准版本号（如 200809L 表示 POSIX.1-2008）           |


#### 基础示例：查询常用系统参数
```c
    long value;
    // 3. 查询单个进程最大文件描述符数
    value = sysconf(_SC_OPEN_MAX);
    printf("单个进程最大文件描述符数: %ld\n", value);

```
```
单个进程最大文件描述符数: 1024
```





