# 一、匿名管道
#### `pipe` （匿名管道）
`pipe`（管道）是用于**进程间通信（IPC）** 的一种机制，可实现同一主机上两个相关进程（通常是父子进程）之间的字节流传输。管道是`单向的`，分为“读端”和“写端”，数据从写端写入，从读端读取。一般在读端（写端）要关闭写端（读端），通信完成后关闭读端写端

```c
#include <unistd.h>
int pipe(int pipefd[2]);
```
- **参数**：`pipefd` 是一个包含两个整数的数组，用于存储管道的文件描述符：
  - `pipefd[0]`：管道的**读端**，用于读取数据
  - `pipefd[1]`：管道的**写端**，用于写入数据
- **返回值**：成功返回 `0`；失败返回 `-1` 并设置 `errno`
#### 核心特性
1. **单向通信**：数据只能从写端流向读端，无法反向传输。
2. **面向字节流**：数据按顺序传输，无消息边界（读取时需自行处理数据分割）。
3. **阻塞特性**：
   - 读端：若管道为空，`read` 会阻塞直到有数据写入或写端关闭。
   - 写端：若管道满（通常约64KB），`write` 会阻塞直到数据被读取。
4. **生命周期**：随进程创建，当所有引用管道的文件描述符被关闭后，管道自动销毁。
#### 基础示例：父子进程通过管道通信
父进程创建子进程后，通过管道向子进程发送数据，子进程读取并打印：
```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
int main() {
    int pipefd[2];
    // 创建管道
    if (pipe(pipefd) == -1) {
        perror("pipe 创建失败");
        exit(1);
    }
    pid_t pid = fork(); // 创建子进程
    if (pid == -1) {
        perror("fork 失败");
        exit(1);
    }
    if (pid == 0) { 
        // 子进程：关闭写端（只需要读）
        close(pipefd[1]);
        char buf[1024];
        // 从管道读端读取数据
        ssize_t n = read(pipefd[0], buf, sizeof(buf));
        if (n == -1) {
            perror("read 失败");
            exit(1);
        }
        printf("子进程收到：%.*s\n", (int)n, buf);
        // 关闭读端
        close(pipefd[0]);
        exit(0);
    } else { 
        // 父进程：关闭读端（只需要写）
        close(pipefd[0]);
        const char *msg = "Hello from 父进程!";
        // 向管道写端写入数据
        if (write(pipefd[1], msg, strlen(msg)) == -1) {
            perror("write 失败");
            exit(1);
        }
        // 关闭写端（触发子进程的 read 返回）
        close(pipefd[1]);
        // 等待子进程结束
        wait(NULL);
        exit(0);
    }
}
```
**输出结果**：
```
子进程收到：Hello from 父进程!
```
#### 关键注意事项
1. **关闭无用端**：使用管道时必须关闭不需要的端（如子进程关闭写端，父进程关闭读端），否则可能导致读端阻塞（等待写端关闭）。
2. **避免管道满阻塞**：若写入数据量超过管道缓冲区大小（通常64KB），`write` 会阻塞，需确保读取方及时处理数据。
3. **双向通信需两个管道**：因管道单向性，若需父子进程互传数据，需创建两个管道（一个用于父到子，一个用于子到父）。
4. **与文件操作的区别**：管道是内存中的临时通道，不对应磁盘文件，`lseek` 等定位操作对管道无效。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# 二、有名管道
#### `mkfifo` 基本介绍
`mkfifo` 是用于创建**命名管道（Named Pipe）** 的系统调用，与匿名管道（`pipe` 创建）不同，命名管道有一个可见的文件系统路径(任意指定)，可用于**不相关进程**之间的通信（匿名管道仅适用于相关进程，如父子进程）。
```c
#include <sys/stat.h>
int mkfifo(const char *pathname, mode_t mode);
```
- **参数**：
  - `pathname`：命名管道在文件系统中的路径（如 `/tmp/myfifo`）。
  - `mode`：管道的权限位（如 `0664` 表示所有者读写、组内读、其他读），最终权限会受进程的 `umask` 影响。
- **返回值**：成功返回 `0`；失败返回 `-1` 并设置 `errno`（如路径已存在会返回错误）。


#### 核心特性
1. **存在于文件系统**：命名管道以特殊文件形式存在（可通过 `ls -l` 查看，文件类型标记为 `p`），但不占用磁盘空间（数据存储在内存中）。
2. **跨进程通信**：无亲缘关系的进程可通过管道路径访问同一管道，突破匿名管道的亲缘关系限制。
3. **阻塞特性**：与匿名管道类似：
   - 读操作：若管道为空，`read` 会阻塞直到有数据写入。
   - 写操作：若管道满，`write` 会阻塞直到数据被读取。
   - 若以非阻塞模式（`O_NONBLOCK`）打开，空管道的读会返回 `0`，满管道的写会返回错误。


#### 基础示例：两个独立进程通过命名管道通信
下面是两个独立程序：一个写数据到命名管道，一个从管道读数据。
##### 写端程序（`fifo_write.c`）
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
int main() {
    const char *fifo_path = "/tmp/myfifo";
    // 创建命名管道（若不存在）
    if (mkfifo(fifo_path, 0664) == -1) {
        perror("mkfifo 失败");
        exit(1);
    }
    // 打开管道（写模式）
    int fd = open(fifo_path, O_WRONLY);
    if (fd == -1) {
        perror("open 失败");
        exit(1);
    }
    const char *msg = "Hello from 写进程!";
    // 向管道写入数据
    if (write(fd, msg, strlen(msg)) == -1) {
        perror("write 失败");
        exit(1);
    }
    printf("写进程：数据已发送\n");
    close(fd);
    return 0;
}
```
##### 读端程序（`fifo_read.c`）
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
int main() {
    const char *fifo_path = "/tmp/myfifo";
    // 确保管道已存在（也可在此处创建）
    if (access(fifo_path, F_OK) == -1) {
        perror("管道不存在");
        exit(1);
    }
    // 打开管道（读模式）
    int fd = open(fifo_path, O_RDONLY);
    if (fd == -1) {
        perror("open 失败");
        exit(1);
    }
    char buf[1024];
    // 从管道读取数据
    ssize_t n = read(fd, buf, sizeof(buf));
    if (n == -1) {
        perror("read 失败");
        exit(1);
    }
    printf("读进程：收到数据：%.*s\n", (int)n, buf);
    close(fd);
    return 0;
}
```
#### 运行步骤与输出
1. 先编译并运行读端程序（会阻塞等待数据）：
   ./fifo_read
2. 再编译并运行写端程序（发送数据后，读端会立即接收）：
   ./fifo_write
3. 输出结果：
   - 写端：`写进程：数据已发送`
   - 读端：`读进程：收到数据：Hello from 写进程!`

#### 关键注意事项
1. **创建时机**：管道必须先被创建（`mkfifo`），才能被读写进程打开；若读写进程同时创建，需处理路径已存在的错误
2. **打开顺序**：若以阻塞模式打开，读端会等待写端打开管道，反之亦然（避免“孤儿”操作）。
3. **权限控制**：`mode` 参数需确保读写进程有足够权限访问管道（如不同用户需设置 `0666` 并配合 `umask`）。
4. **清理管道文件**：命名管道不会自动删除，使用完毕后需手动删除（`unlink(fifo_path)` 或 `rm /tmp/myfifo`）。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
### 判断是否存在管道
`access` 是一个系统调用函数，核心作用是**检查当前进程对指定路径的文件/目录是否拥有特定权限**（如读、写、执行），或单纯检查文件是否存在。
#### 1. 核心功能与参数
函数原型（以 C 语言为例）：
```c
#include <unistd.h>
int access(const char *pathname, int mode);
```
- **pathname**：要检查的文件/目录路径（如 `/tmp/myfifo`）。
- **mode**：检查的权限类型，常用取值有 3 个：
  - `F_OK`：仅检查文件/目录是否**存在**（不检查权限），这是与 `mkfifo` 配合时最常用的取值。
  - `R_OK`：检查当前进程是否有**读权限**。
  - `W_OK`：检查当前进程是否有**写权限**。
  - `X_OK`：检查当前进程是否有**执行权限**（对目录而言是“进入权限”）。

#### 2. 返回值说明
- 返回 `0`：表示检查通过（如文件存在，或拥有指定权限）。
- 返回 `-1`：表示检查失败（如文件不存在、权限不足），具体原因通过 `errno` 区分（如 `ENOENT` 表示文件不存在，`EACCES` 表示权限不足）。
#### 3. 典型用法（与 mkfifo 配合）
比如在创建命名管道前，先用 `access` 检查路径是否已存在，避免重复创建报错：
```c
#include <unistd.h>
#include <sys/stat.h>
#include <stdio.h>
#include <errno.h>
int main() {
    const char *fifo_path = "/tmp/myfifo";
    // 1. 先检查管道文件是否已存在
    if (access(fifo_path, F_OK) == -1) {
        // 文件不存在，创建命名管道
        if (mkfifo(fifo_path, 0666) == -1) {
            perror("mkfifo failed"); // 打印具体错误（如权限不足）
            return 1;
        }
        printf("FIFO created successfully\n");
    } else {
        printf("FIFO already exists, no need to create\n");
    }
    // 后续操作（打开、读写管道）...
    return 0;
}
```
### 4. 关键注意点
- `access` 检查的是**当前进程的实际权限**（受进程的 UID、GID 影响），而非文件的“所有者权限”（如 root 进程可能绕过部分权限检查）。
- 若路径是符号链接，`access` 会跟随链接检查最终指向的文件，而非链接本身。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
### 清除管道
#### `unlink` 基本介绍
`unlink` 是 用于**删除文件系统中文件或符号链接**的系统调用，核心作用是移除文件的“目录项”（即文件名与inode的关联）。对于命名管道（FIFO），`unlink` 是使用后清理其文件路径的关键操作。
```c
#include <unistd.h>
int unlink(const char *pathname);
```
- **参数**：`pathname` 是要删除的文件/符号链接/命名管道的路径（如 `/tmp/myfifo`）。
- **返回值**：成功返回 `0`；失败返回 `-1` 并设置 `errno`（如路径不存在、权限不足）。
#### 核心特性（重点：与命名管道的关系）
1. **删除的是“路径”，不是“数据”**  
   - 对普通文件：`unlink` 移除文件名，但文件的实际数据（存储在inode中）会在“所有进程关闭该文件的文件描述符”后才被系统回收（即“延迟删除”）。
   - 对命名管道：`unlink` 仅删除文件系统中的管道路径（如 `/tmp/myfifo`），但已打开该管道的进程仍可继续通过文件描述符通信，直到所有进程关闭描述符，管道才彻底销毁。
2. **与 `rm` 命令的关系**  
   Shell 中的 `rm` 命令本质就是调用 `unlink` 实现的（删除普通文件/符号链接/命名管道时，`rm filename` = `unlink(filename)`）。
#### 基础示例：使用 `unlink` 清理命名管道
创建命名管道并使用后，通过 `unlink` 删除其路径，避免残留文件：
```c
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    const char *fifo_path = "/tmp/myfifo";

    // 1. 创建命名管道
    if (mkfifo(fifo_path, 0664) == -1) {
        perror("mkfifo failed");
        exit(1);
    }
    printf("管道创建成功：%s\n", fifo_path);

    // 2. 打开并使用管道（示例：写数据）
    int fd = open(fifo_path, O_WRONLY);
    if (fd == -1) {
        perror("open failed");
        unlink(fifo_path); // 出错时也要清理管道
        exit(1);
    }
    const char *msg = "Hello via FIFO";
    write(fd, msg, strlen(msg));
    close(fd);
    printf("数据写入完成\n");

    // 3. 清理：删除管道路径
    if (unlink(fifo_path) == -1) {
        perror("unlink failed");
        exit(1);
    }
    printf("管道路径已删除\n");

    return 0;
}
```
**输出结果**：
```
管道创建成功：/tmp/myfifo
数据写入完成
管道路径已删除
```
#### 关键注意事项
1. **“删除后仍可通信”的特殊场景**  
   若进程A先打开命名管道（获得文件描述符），再调用 `unlink` 删除路径，此时进程B无法再通过路径打开管道，但进程A仍可通过已有的文件描述符读写数据（直到关闭描述符）。这一特性可用于“隐藏”管道路径，避免被其他进程误访问。
2. **权限要求**  
   调用 `unlink` 不需要对目标文件有读写权限，但需要对文件所在的**目录**有“写权限”和“执行权限”（写权限用于修改目录项，执行权限用于访问目录内文件）。
3. **不能删除目录**  
   `unlink` 仅用于删除文件、符号链接、命名管道等“非目录”文件；若要删除目录，需使用 `rmdir`（删除空目录）或 `rm -r`（递归删除，本质调用 `rmdir`）。
#### 典型应用场景
- **清理命名管道**：创建命名管道后，必须用 `unlink` 删除其路径，否则文件会残留（系统不会自动清理），下次创建会报错。
- **临时文件管理**：创建临时文件（如 `/tmp/tmpfile`）后，用 `unlink` 提前删除路径，确保进程退出时文件数据被回收（避免临时文件残留）。
- **安全通信**：删除命名管道路径后，仅已打开管道的进程可继续通信，防止未授权进程通过路径接入。
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# 共享内存

#### `shm_open`（共享内存对象创建/打开）
`shm_open` 是用于**进程间通信（IPC）** 的一种机制，用于创建或打开一个共享内存对象，使得多个进程可以通过映射同一段内存区域实现高效的数据共享。共享内存是速度最快的IPC方式，因为数据不需要在进程间复制。

```c
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/stat.h>
int shm_open(const char *name, int oflag, mode_t mode);
```

- **参数**：
  - `name`：共享内存对象的名称，必须以斜杠开头（如 "/my_shm"），遵循POSIX IPC名称规则
  - `oflag`：打开方式标志，可组合使用：
    - `O_CREAT`：若对象不存在则创建
    - `O_RDONLY`：只读方式打开
    - `O_RDWR`：读写方式打开
    - `O_EXCL`：与 `O_CREAT` 结合使用，若对象已存在则返回错误
  - `mode`：当使用 `O_CREAT` 时，指定新对象的权限（如 `0666` 表示所有用户可读写）
- **返回值**：成功返回共享内存对象的文件描述符；失败返回 `-1` 并设置 `errno`

#### 核心特性
1. **命名机制**：通过唯一名称标识共享内存对象，支持不相关进程间共享。
2. **生命周期**：
   - 由 `shm_unlink` 显式删除或系统重启时销毁
   - 即使所有进程关闭了文件描述符，对象依然存在
3. **大小设置**：创建后需通过 `ftruncate` 设置大小，映射时需指定相同大小。
4. **映射操作**：需配合 `mmap` 将共享内存映射到进程地址空间后才能访问。
5. **同步机制**：本身不提供同步，需结合信号量、互斥锁等机制防止数据竞争。

#### 基础示例：两个进程通过共享内存通信
写进程创建共享内存并写入数据，读进程打开同一共享内存并读取数据：

**写进程（writer.c）**
```c
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SHM_NAME "/my_shared_memory"
#define SHM_SIZE 1024

int main() {
    // 创建并打开共享内存对象
    int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
    if (shm_fd == -1) {
        perror("shm_open 失败");
        exit(1);
    }
    // 设置共享内存大小
    if (ftruncate(shm_fd, SHM_SIZE) == -1) {
        perror("ftruncate 失败");
        exit(1);
    }
    // 将共享内存映射到进程地址空间
    void *shm_ptr = mmap(NULL, SHM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shm_ptr == MAP_FAILED) {
        perror("mmap 失败");
        exit(1);
    }
    // 写入数据
    const char *msg = "Hello from writer process!";
    strncpy(shm_ptr, msg, SHM_SIZE - 1);
    // 清理资源
    munmap(shm_ptr, SHM_SIZE);
    close(shm_fd);
    // 保持共享内存存在，等待读进程读取
    printf("数据已写入共享内存，按任意键继续（将删除共享内存）...\n");
    getchar();
    // 删除共享内存对象
    shm_unlink(SHM_NAME);
    return 0;
}
```
**读进程（reader.c）**
```c
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#define SHM_NAME "/my_shared_memory"
#define SHM_SIZE 1024
int main() {
    // 打开已存在的共享内存对象
    int shm_fd = shm_open(SHM_NAME, O_RDONLY, 0666);
    if (shm_fd == -1) {
        perror("shm_open 失败");
        exit(1);
    }
    // 将共享内存映射到进程地址空间
    void *shm_ptr = mmap(NULL, SHM_SIZE, PROT_READ, MAP_SHARED, shm_fd, 0);
    if (shm_ptr == MAP_FAILED) {
        perror("mmap 失败");
        exit(1);
    }
    // 读取并打印数据
    printf("从共享内存读取到：%s\n", (char *)shm_ptr);
    // 清理资源
    munmap(shm_ptr, SHM_SIZE);
    close(shm_fd);
    return 0;
}
```

**操作与输出**：
1. 先运行写进程：`./writer`
   ```
   数据已写入共享内存，按任意键继续（将删除共享内存）...
   ```
2. 再运行读进程：`./reader`
   ```
   从共享内存读取到：Hello from writer process!
   ```
3. 回到写进程按任意键，共享内存被删除
#### 关键注意事项
1. **名称规范**：共享内存名称必须以斜杠开头，且不能包含其他斜杠（如 "/my_shm" 有效，"/my/shm" 无效）。
2. **权限设置**：创建时的 `mode` 参数会与进程的 umask 结合，实际权限为 `mode & ~umask`。
3. **大小管理**：`ftruncate` 设置的大小必须与所有进程 `mmap` 时使用的大小一致，否则可能导致错误。
4. **同步问题**：多个进程同时读写时必须使用同步机制（如 `sem_open` 创建的信号量），否则会导致数据不一致。
5. **资源清理**：`shm_unlink` 只是删除名称关联，实际内存释放需等所有进程解除映射（`munmap`）后。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#### `shm_unlink`（删除共享内存对象链接）
`shm_unlink` 用于删除共享内存对象的名称链接，是管理共享内存生命周期的关键函数。与文件系统的 `unlink` 类似，它不会立即销毁共享内存数据，而是在所有进程解除映射并关闭文件描述符后才真正释放资源。
```c
#include <sys/mman.h>
int shm_unlink(const char *name);
```
- **参数**：`name` 是要删除的共享内存对象的名称（与 `shm_open` 中使用的名称一致，如 "/my_shm"）
- **返回值**：成功返回 `0`；失败返回 `-1` 并设置 `errno`
#### 核心特性
1. **延迟销毁**：仅删除共享内存的名称引用，不直接释放内存。当所有进程都解除映射（`munmap`）且关闭文件描述符后，内核才会真正释放共享内存。
2. **名称不可用**：调用后，其他进程无法再通过该名称 `shm_open` 打开此共享内存对象，但已打开的进程仍可正常使用。
3. **权限要求**：调用进程必须对共享内存对象具有写权限，或为对象的创建者。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#### `ftruncate`（调整文件或共享内存大小）
`ftruncate` 用于调整已打开文件或共享内存对象的大小，在共享内存编程中常用来设置共享内存区域的容量。对于普通文件，它可以截断或扩展文件大小；对于共享内存对象，它是设置可映射内存区域大小的必要操作。
```c
#include <unistd.h>
#include <sys/types.h>
int ftruncate(int fd, off_t length);
```
- **参数**：
  - `fd`：已打开的文件描述符（可以是普通文件或 `shm_open` 返回的共享内存描述符）
  - `length`：目标大小（字节数），若小于当前大小则截断文件，若大于当前大小则扩展文件
- **返回值**：成功返回 `0`；失败返回 `-1` 并设置 `errno`
#### 核心特性
**共享内存依赖**：使用 `shm_open` 创建的共享内存对象必须通过 `ftruncate` 设置大小后才能被 `mmap` 映射。
**文件偏移量**：不影响文件的当前读写偏移量（由 `lseek` 控制）。
#### 关键注意事项
1. **共享内存必备步骤**：`shm_open` 创建的共享内存初始大小为 0，必须通过 `ftruncate` 设置实际大小后才能被 `mmap` 正确映射。
2. **文件描述符要求**：用于共享内存时，文件描述符必须以 `O_RDWR` 模式打开，否则 `ftruncate` 会失败（返回 `-1` 并设置 `EINVAL`）。
3. **映射一致性**：`ftruncate` 调整大小后，已存在的 `mmap` 映射不会自动更新，需要重新映射才能使用新大小的内存区域。
4. **权限限制**：对普通文件操作时，需要有写权限；对共享内存操作时，需要符合 `shm_open` 设定的权限。
5. **错误场景**：
   - 若 `length` 为负数，返回失败（`EINVAL`）
   - 若文件是只读打开的，返回失败（`EBADF` 或 `EACCES`）
   - 若超过系统对文件/共享内存的大小限制，返回失败（`EFBIG`）
#### 与 `truncate` 的区别
`truncate` 与 `ftruncate` 功能类似，但 `truncate` 通过文件名操作，而 `ftruncate` 通过已打开的文件描述符操作。在共享内存编程中，只能使用 `ftruncate`（因共享内存对象没有传统意义上的文件名路径）。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#### `mmap`（内存映射）
`mmap` 是一种将文件或其他对象映射到进程地址空间的机制，使得进程可以像访问内存一样操作文件内容。在进程间通信中，常与 `shm_open` 配合使用，实现共享内存的高效访问。
```c
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```
- **参数**：
  - `addr`：指定映射的起始地址，通常设为 `NULL` 由系统自动分配
  - `length`：映射的大小（字节），必须与共享内存/文件的大小匹配
  - `prot`：内存保护标志（权限），可组合使用：
    - `PROT_READ`：可读
    - `PROT_WRITE`：可写
    - `PROT_EXEC`：可执行
    - `PROT_NONE`：不可访问
  - `flags`：映射类型标志，关键组合：
    - `MAP_SHARED`：共享映射，修改会反映到文件/其他进程
    - `MAP_PRIVATE`：私有映射，修改仅对当前进程有效（写时复制）
  - `fd`：要映射的文件/共享内存的文件描述符
  - `offset`：映射的起始偏移量（必须是页大小的整数倍，通常为 0）
- **返回值**：成功返回映射区域的起始地址；失败返回 `MAP_FAILED`（通常为 `(void *)-1`）并设置 `errno`
#### 核心特性
1. **内存映射 I/O**：将文件操作转换为内存操作，避免 `read`/`write` 系统调用的开销。
2. **共享机制**：`MAP_SHARED` 模式下，多个进程可通过映射同一文件/共享内存实现数据共享。
3. **按需加载**：系统采用分页机制，仅在访问时才将数据加载到物理内存。
4. **自动同步**：对共享映射的修改会由内核自动同步到文件（或共享内存）。
5. **无显式 I/O**：无需调用 `read`/`write`，直接通过指针操作数据。
#### 基础示例：使用 `mmap` 实现共享内存通信
**写进程（mmap_writer.c）**
```c
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define SHM_NAME "/mmap_shm"
#define SHM_SIZE 1024
int main() {
    // 创建共享内存
    int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
    if (shm_fd == -1) { perror("shm_open"); exit(1); }
    // 设置大小
    ftruncate(shm_fd, SHM_SIZE);
    // 映射共享内存到进程地址空间
    char *shm_ptr = mmap(NULL, SHM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shm_ptr == MAP_FAILED) { perror("mmap"); exit(1); }
    // 写入数据
    strcpy(shm_ptr, "Hello via mmap!");
    printf("已写入共享内存: %s\n", shm_ptr);
    // 等待读进程读取
    printf("按任意键继续...\n");
    getchar();
    // 清理
    munmap(shm_ptr, SHM_SIZE);
    close(shm_fd);
    shm_unlink(SHM_NAME);
    return 0;
}
```
**读进程（mmap_reader.c）**
```c
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#define SHM_NAME "/mmap_shm"
#define SHM_SIZE 1024
int main() {
    // 打开共享内存
    int shm_fd = shm_open(SHM_NAME, O_RDONLY, 0666);
    if (shm_fd == -1) { perror("shm_open"); exit(1); }
    // 映射共享内存
    char *shm_ptr = mmap(NULL, SHM_SIZE, PROT_READ, MAP_SHARED, shm_fd, 0);
    if (shm_ptr == MAP_FAILED) { perror("mmap"); exit(1); }
    // 读取数据
    printf("从共享内存读取: %s\n", shm_ptr);
    // 清理
    munmap(shm_ptr, SHM_SIZE);
    close(shm_fd);
    return 0;
}
```

**输出结果**：
1. 写进程：
   ```
   已写入共享内存: Hello via mmap!
   按任意键继续...
   ```
2. 读进程：
   ```
   从共享内存读取: Hello via mmap!
   ```

#### 关键注意事项
1. **大小匹配**：`mmap` 的 `length` 参数必须与 `ftruncate` 设置的共享内存大小一致，否则可能导致越界访问。
2. **权限兼容**：`prot` 权限不能超过文件描述符 `fd` 的打开权限（如只读打开的文件不能映射为 `PROT_WRITE`）。
3. **同步控制**：
   - `msync`：可显式将修改同步到文件（避免依赖内核自动同步）
   - `MAP_SYNC`（部分系统支持）：强制写操作实时同步到存储
4. **解除映射**：不再使用时必须调用 `munmap` 解除映射，否则可能导致内存泄漏。
5. **信号处理**：若映射区域被修改后进程收到信号中断，修改仍可能被保留。
6. **常见错误**：
   - `EINVAL`：`length` 为 0 或 `offset` 不是页对齐的
   - `ENOMEM`：内存不足无法创建映射
   - `EBADF`：`fd` 不是有效的文件描述符


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#### `munmap`（解除内存映射）
`munmap` 用于解除通过 `mmap` 创建的内存映射，释放进程地址空间中与文件或共享内存关联的区域。它是内存映射生命周期管理的重要函数，确保进程不再访问已释放的映射区域。
```c
#include <sys/mman.h>
int munmap(void *addr, size_t length);
```
- **参数**：
  - `addr`：通过 `mmap` 返回的映射区域起始地址（必须准确，不能是区域内的任意地址）
  - `length`：要解除映射的大小（字节），必须与 `mmap` 时指定的 `length` 一致
- **返回值**：成功返回 `0`；失败返回 `-1` 并设置 `errno`

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# 消息队列(POSIX)
- 功能更强，适合现代嵌入式内核
- 旧版参考System V 消息队列，兼容性优先，适合老旧 / 极简内核
#### `mq_open`（消息队列创建/打开）
`mq_open` 是用于**进程间通信（IPC）** 的机制，用于创建或打开一个命名消息队列，实现不同进程间通过消息进行异步通信。消息队列允许进程发送和接收带有优先级的消息，相比管道具有更强的灵活性。
```c
#include <mqueue.h>
mqd_t mq_open(const char *name, int oflag, mode_t mode, struct mq_attr *attr);
```
- **参数**：
  - `name`：消息队列的名称，必须以斜杠开头（如 "/my_queue"），遵循POSIX IPC命名规则
  - `oflag`：打开方式标志，可组合使用：
    - `O_CREAT`：若队列不存在则创建
    - `O_RDONLY`：只读方式打开（只能接收消息）
    - `O_WRONLY`：只写方式打开（只能发送消息）
    - `O_RDWR`：读写方式打开
    - `O_EXCL`：与 `O_CREAT` 结合，若队列已存在则返回错误
  - `mode`：当使用 `O_CREAT` 时，指定队列的权限（如 `0666`）
  - `attr`：指向 `mq_attr` 结构的指针，用于设置新队列的属性（如消息最大数量、消息最大大小），为 `NULL` 则使用默认值
- **返回值**：成功返回消息队列描述符（`mqd_t` 类型）；失败返回 `-1` 并设置 `errno`
#### 核心特性
1. **消息优先级**：每条消息可以设置优先级（0-31，数值越大优先级越高），接收时按优先级排序。
2. **异步通信**：发送方和接收方可独立运行，无需同步等待。
3. **持久化特性**：消息队列及其内容在进程退出后仍然存在，直到被 `mq_unlink` 删除。
4. **容量限制**：队列可存储的最大消息数和单条消息最大大小由 `mq_attr` 结构指定，超出限制时发送会阻塞（或返回错误，取决于设置）。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#### `mq_send`（消息队列消息发送）
`mq_send` 是 POSIX 消息队列的**消息发送接口**，用于向已打开的命名消息队列中写入一条带优先级的消息，支持阻塞或非阻塞模式，实现进程间的异步数据传递，消息按优先级排序存储。
```c
#include <mqueue.h>
int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned int msg_prio);
```
- **参数**：
  - `mqdes`：`mq_open` 返回的消息队列描述符，标识要操作的目标队列
  - `msg_ptr`：指向待发送消息数据的指针，可存储自定义结构化数据（如字符串、结构体）
  - `msg_len`：待发送消息的字节长度，必须小于等于队列的 `mq_msgsize`（单条消息最大长度）
  - `msg_prio`：消息优先级，取值范围为 0~31（数值越大优先级越高），相同优先级按 FIFO 排序
- **返回值**：成功返回 `0`；失败返回 `-1` 并设置 `errno`（如队列满时 `errno=EAGAIN`，消息过长时 `errno=EMSGSIZE`）
#### 核心特性
1. **优先级控制**：通过 `msg_prio` 指定消息优先级，队列中高优先级消息优先被接收。
2. **阻塞策略**：默认阻塞模式下，队列满时会阻塞等待，直到队列有空闲空间；非阻塞模式（`O_NONBLOCK`）下直接返回 `EAGAIN`。
3. **数据完整性**：消息以整体形式发送，接收方会完整读取，不会出现部分消息的情况。
4. **长度限制**：消息长度必须严格遵守队列的 `mq_msgsize` 限制，否则发送失败。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#### `mq_receive`（消息队列消息接收）
`mq_receive` 是 POSIX 消息队列的**消息接收接口**，用于从指定队列中读取一条消息，优先获取高优先级消息，支持阻塞或非阻塞模式，是消息队列的核心接收操作。
```c
#include <mqueue.h>
ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned int *msg_prio);
```
- **参数**：
  - `mqdes`：`mq_open` 返回的消息队列描述符，标识要读取的队列
  - `msg_ptr`：指向接收缓冲区的指针，需提前分配内存，大小必须大于等于队列的 `mq_msgsize`
  - `msg_len`：接收缓冲区的字节长度，必须大于等于队列的 `mq_msgsize`（否则返回错误）
  - `msg_prio`：输出参数，用于存储接收消息的优先级，可传入 `NULL` 忽略优先级信息
- **返回值**：成功返回接收消息的实际字节长度；失败返回 `-1` 并设置 `errno`（如队列空时 `errno=EAGAIN`，缓冲区过小 `errno=EMSGSIZE`）
#### 核心特性
1. **优先级读取**：始终优先读取队列中优先级最高的消息，同优先级消息按 FIFO 顺序读取。
2. **阻塞策略**：默认阻塞模式下，队列空时会阻塞等待，直到队列有新消息；非阻塞模式下直接返回 `EAGAIN`。
3. **缓冲区要求**：缓冲区大小必须满足队列的 `mq_msgsize` 要求，否则无法接收消息并返回错误。
4. **优先级反馈**：通过 `msg_prio` 参数可获取接收消息的优先级，支持业务层基于优先级处理逻辑。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


#### `mq_timedsend`（带超时的消息发送）
`mq_timedsend` 是 `mq_send` 的扩展版本，用于向消息队列发送消息时设置超时时间。当消息队列已满无法立即发送时，它会阻塞等待直到超时，避免进程无限期阻塞。
```c
#include <mqueue.h>
#include <time.h>
int mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len, 
                 unsigned int msg_prio, const struct timespec *abs_timeout);
```
- **参数**：
  - `mqdes`：`mq_open` 返回的消息队列描述符
  - `msg_ptr`：指向要发送的消息数据的指针
  - `msg_len`：消息数据的长度（字节），必须 ≤ 队列的 `mq_msgsize` 属性
  - `msg_prio`：消息优先级（0-31，数值越大优先级越高）
  - `abs_timeout`：绝对超时时间（`struct timespec` 类型），指定等待的最晚时间点
- **返回值**：成功返回 `0`；失败返回 `-1` 并设置 `errno`（超时会设置 `ETIMEDOUT`）

#### 核心特性
1. **超时控制**：通过 `abs_timeout` 指定绝对超时时间，而非相对时间（如设置为 "10:00:00" 而非 "等待10秒"）。
2. **阻塞行为**：
   - 若队列未满，立即发送消息并返回
   - 若队列已满，阻塞等待直到有空间或超时
   - 与 `O_NONBLOCK` 标志不兼容（同时使用会返回错误）
3. **时间精度**：基于系统时钟，精度通常为微秒级（取决于系统实现）。
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#### `mq_timedreceive`（带超时的消息接收）
`mq_timedreceive` 是 `mq_receive` 的扩展版本，用于从消息队列接收消息时设置超时时间。当消息队列为空无法无法立即接收消息时，它会阻塞等待直到超时时间到达，避免进程无限期等待。
```c
#include <mqueue.h>
#include <time.h>
ssize_t mq_timedreceive(mqd_t mqdes, char *msg_ptr, size_t msg_len,
                       unsigned int *msg_prio, const struct timespec *abs_timeout);
```
- **参数**：
  - `mqdes`：`mq_open` 返回的消息队列描述符
  - `msg_ptr`：指向接收缓冲区的指针，用于存储存储接收到的消息
  - `msg_len`：接收缓冲区的大小（字节），必须 ≥ 队列的 `mq_msgsize` 属性
  - `msg_prio`：用于存储接收消息的优先级（可为 `NULL`，表示不关心优先级）
  - `abs_timeout`：绝对超时时间（`struct timespec` 类型），指定等待的最晚时间点
- **返回值**：成功返回接收到的消息字节数；失败返回 `-1` 并设置 `errno`（超时会设置 `ETIMEDOUT`）

#### 核心特性
1. **超时控制**：通过绝对时间指定最长等待时间，超时后不再阻塞并返回错误。
2. **优先级接收**：默认接收队列中优先级最高的消息，若多个消息优先级相同则按发送顺序接收。
3. **阻塞行为**：
   - 若队列非空，立即接收消息并返回
   - 若队列为空，阻塞等待直到有消息或超时
   - 与 `O_NONBLOCK` 标志不兼容（同时使用会返回错误）


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#### `mq_unlink`（删除消息队列名称链接）
`mq_unlink` 用于删除消息队列的名称引用，是消息队列生命周期管理的重要函数。它与文件系统的 `unlink` 操作类似，不会立即销毁消息队列本身，而是在所有进程关闭该队列的文件描述符后才彻底释放资源。

```c
#include <mqueue.h>
int mq_unlink(const char *name);
```
- **参数**：`name` 是要删除的消息队列的名称（必须与 `mq_open` 中使用的名称一致，如 "/my_queue"）
- **返回值**：成功返回 `0`；失败返回 `-1` 并设置 `errno`
#### 关键注意事项
1. **与 `mq_close` 的区别**：
   - `mq_close`：仅关闭当前进程的队列描述符，不影响队列存在性
   - `mq_unlink`：删除队列名称，阻止新进程访问，但不影响已有描述符的使用
2. **资源释放时机**：只有当所有进程都关闭了队列描述符，且已执行 `mq_unlink` 时，消息队列才会被彻底销毁并释放资源。
3. **常见错误**：
   - `ENOENT`：指定名称的消息队列不存在
   - `EACCES`：调用进程没有足够权限执行此操作
4. **最佳实践**：建议由消息队列的创建者负责调用 `mq_unlink`，通常在确认所有接收方都已获取队列引用后执行，以避免资源泄漏。
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#### `mq_close`（消息队列描述符关闭）
`mq_close` 用于**关闭进程与消息队列的关联**，释放当前进程持有的消息队列文件描述符，但不会删除队列本身，队列资源仍保留在系统中。
```c
#include <mqueue.h>
int mq_close(mqd_t mqdes);
```
- **参数**：
  - `mqdes`：`mq_open` 返回的消息队列描述符，标识要关闭的队列关联
- **返回值**：成功返回 `0`；失败返回 `-1` 并设置 `errno`（如描述符无效时 `errno=EBADF`）
#### 核心特性
1. **仅释放关联**：关闭后当前进程无法再通过该描述符操作队列，但其他进程的关联不受影响。
2. **引用计数**：系统为队列维护引用计数，当所有关联进程都调用 `mq_close` 后，队列仍存在，需通过 `mq_unlink` 删除。
3. **资源释放**：关闭后释放当前进程分配给该描述符的相关资源，避免文件描述符泄漏。
4. **幂等性**：对已关闭的描述符重复调用会返回错误（`errno=EBADF`），需避免无效调用。


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━




#### 基础示例：使用消息队列进行进程间通信
**发送进程（mq_sender.c）**
```c
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#define QUEUE_NAME "/my_message_queue"
#define MSG_SIZE 100
#define PRIORITY 1
int main() {
    // 打开消息队列（创建如果不存在）
    mqd_t mq_fd = mq_open(QUEUE_NAME, O_CREAT | O_WRONLY, 0666, NULL);
    if (mq_fd == -1) {
        perror("mq_open 失败");
        exit(1);
    }
    // 发送消息
    const char *msg = "Hello from sender!";
    if (mq_send(mq_fd, msg, strlen(msg) + 1, PRIORITY) == -1) {
        perror("mq_send 失败");
        exit(1);
    }
    printf("已发送消息: %s\n", msg);
    // 清理
    mq_close(mq_fd);
    return 0;
}
```

**接收进程（mq_receiver.c）**
```c
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#define QUEUE_NAME "/my_message_queue"
#define MSG_SIZE 100
int main() {
    // 打开消息队列（只读方式）
    mqd_t mq_fd = mq_open(QUEUE_NAME, O_RDONLY, 0666, NULL);
    if (mq_fd == -1) {
        perror("mq_open 失败");
        exit(1);
    }
    // 接收消息
    char buf[MSG_SIZE];
    unsigned int priority;
    ssize_t bytes_read = mq_receive(mq_fd, buf, MSG_SIZE, &priority);
    if (bytes_read == -1) {
        perror("mq_receive 失败");
        exit(1);
    }
    printf("收到消息: %s (优先级: %u)\n", buf, priority);
    // 清理
    mq_close(mq_fd);
    mq_unlink(QUEUE_NAME);  // 删除消息队列
    return 0;
}
```

**输出结果**：
1. 发送进程：
   ```
   已发送消息: Hello from sender!
   ```
2. 接收进程：
   ```
   收到消息: Hello from sender! (优先级: 1)
   ```
#### 关键注意事项
1. **名称规范**：同共享内存类似，消息队列名称必须以斜杠开头，且不能包含其他斜杠。
2. **属性设置**：创建队列时通过 `mq_attr` 可指定：
   - `mq_maxmsg`：队列最大消息数（系统有上限）
   - `mq_msgsize`：单条消息最大字节数
   这些属性在队列创建后不能修改。
3. **阻塞行为**：
   - 发送（`mq_send`）：队列满时默认阻塞，可通过 `O_NONBLOCK` 标志改为非阻塞（返回 `EAGAIN`）
   - 接收（`mq_receive`）：队列空时默认阻塞，`O_NONBLOCK` 标志下返回 `EAGAIN`
4. **消息格式**：消息是字节流，需自行定义格式（如添加长度字段或分隔符）。
5. **资源清理**：
   - `mq_close`：关闭队列描述符，但队列本身继续存在
   - `mq_unlink`：删除队列名称，所有进程关闭描述符后队列被销毁
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#### 基础示例：使用 `mq_timedsend` 发送消息并设置超时
```c
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#define QUEUE_NAME "/timed_queue"
#define MSG_SIZE 50
#define QUEUE_MAX_MSG 1  // 队列最多容纳1条消息（便于测试超时）

int main() {
    // 定义队列属性（限制队列大小以触发阻塞）
    struct mq_attr attr = {
        .mq_flags = 0,
        .mq_maxmsg = QUEUE_MAX_MSG,
        .mq_msgsize = MSG_SIZE,
        .mq_curmsgs = 0
    };

    // 创建并打开消息队列
    mqd_t mq_fd = mq_open(QUEUE_NAME, O_CREAT | O_WRONLY, 0666, &attr);
    if (mq_fd == -1) {
        perror("mq_open 失败");
        exit(1);
    }

    // 第一条消息：队列未满，可正常发送
    const char *msg1 = "First message";
    if (mq_send(mq_fd, msg1, strlen(msg1) + 1, 1) == -1) {
        perror("mq_send 第一条消息失败");
        exit(1);
    }
    printf("已发送: %s\n", msg1);

    // 第二条消息：队列已满，使用超时发送
    const char *msg2 = "Second message (with timeout)";
    struct timespec timeout;
    
    // 设置超时时间为当前时间 + 3秒（绝对时间）
    if (clock_gettime(CLOCK_REALTIME, &timeout) == -1) {
        perror("clock_gettime 失败");
        exit(1);
    }
    timeout.tv_sec += 3;  // 超时时间增加3秒

    printf("尝试发送第二条消息（将等待3秒超时）...\n");
    int ret = mq_timedsend(mq_fd, msg2, strlen(msg2) + 1, 2, &timeout);
    if (ret == -1) {
        if (errno == ETIMEDOUT) {
            printf("发送超时: 超过3秒仍无法发送消息\n");
        } else {
            perror("mq_timedsend 失败");
            exit(1);
        }
    } else {
        printf("已发送: %s\n", msg2);
    }

    // 清理
    mq_close(mq_fd);
    mq_unlink(QUEUE_NAME);
    return 0;
}
```
**输出结果**：
```
已发送: First message
尝试发送第二条消息（将等待3秒超时）...
发送超时: 超过3秒仍无法发送消息
```
#### 关键注意事项
1. **超时时间类型**：`abs_timeout` 必须是绝对时间（基于 `CLOCK_REALTIME` 时钟），需通过 `clock_gettime` 获取当前时间后计算，而非直接设置相对时间。
2. **时钟选择**：超时基于实时时钟（`CLOCK_REALTIME`），若系统时间被调整（如NTP同步），可能影响超时行为。
3. **消息长度限制**：`msg_len` 必须 ≤ 队列的 `mq_msgsize` 属性，否则返回 `EMSGSIZE` 错误。
4. **与非阻塞冲突**：若消息队列以 `O_NONBLOCK` 模式打开，`mq_timedsend` 会返回 `EINVAL` 错误，二者不可同时使用。
5. **常见错误**：
   - `ETIMEDOUT`：超时未发送成功
   - `EAGAIN`：队列满且设置了 `O_NONBLOCK`（不应该出现在 `mq_timedsend` 中）
   - `EINVAL`：参数无效（如超时时间为负）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#### 基础示例：使用 `mq_timedreceive` 接收消息并设置超时
```c
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#define QUEUE_NAME "/timed_recv_queue"
#define MSG_SIZE 100

int main() {
    // 打开消息队列（只读方式）
    mqd_t mq_fd = mq_open(QUEUE_NAME, O_CREAT | O_RDONLY, 0666, NULL);
    if (mq_fd == -1) {
        perror("mq_open 失败");
        exit(1);
    }

    // 设置超时时间为当前时间 + 3秒
    struct timespec timeout;
    if (clock_gettime(CLOCK_REALTIME, &timeout) == -1) {
        perror("clock_gettime 失败");
        exit(1);
    }
    timeout.tv_sec += 3;  // 3秒后超时

    printf("等待消息（3秒超时）...\n");
    char buf[MSG_SIZE];
    unsigned int priority;
    
    // 尝试接收消息，带超时
    ssize_t len = mq_timedreceive(mq_fd, buf, MSG_SIZE, &priority, &timeout);
    if (len == -1) {
        if (errno == ETIMEDOUT) {
            printf("接收超时: 3秒内未收到消息\n");
        } else {
            perror("mq_timedreceive 失败");
            exit(1);
        }
    } else {
        printf("收到消息: %.*s (优先级: %u, 长度: %zd字节)\n", 
               (int)len, buf, priority, len);
    }

    // 清理
    mq_close(mq_fd);
    mq_unlink(QUEUE_NAME);
    return 0;
}
```
**输出结果（无发送方时）**：
```
等待消息（3秒超时）...
接收超时: 3秒内未收到消息
```
**输出结果（有发送方时）**：
```
等待消息（3秒超时）...
收到消息: Hello from sender! (优先级: 2, 长度: 18字节)
```
#### 关键注意事项
1. **超时时间设置**：`abs_timeout` 必须是基于 `CLOCK_REALTIME` 的绝对时间，需通过 `clock_gettime` 获取当前时间后计算（如当前时间+5秒），不能直接使用相对时间。
2. **缓冲区大小**：`msg_len` 必须 ≥ 消息队列的 `mq_msgsize` 属性，否则会返回 `EMSGSIZE` 错误（即使实际消息更小）。
3. **优先级参数**：`msg_prio` 可为 `NULL`，表示不需要获取消息优先级；若不为 `NULL`，则会存储接收消息的优先级值。
4. **与非阻塞冲突**：若消息队列以 `O_NONBLOCK` 模式打开，调用 `mq_timedreceive` 会返回 `EINVAL` 错误。
5. **常见错误**：
   - `ETIMEDOUT`：超时未接收到消息
   - `EMSGSIZE`：接收缓冲区大小小于队列的 `mq_msgsize`
   - `EINVAL`：超时时间无效或与非阻塞模式冲突

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#### `clock_gettime`（高精度时间获取）
`clock_gettime` 是 Linux 系统中用于获取**高精度时间**的核心函数，支持多种时间源（如系统时间、单调时间），广泛用于计时、性能分析和时间同步场景。
### 函数原型
```c
#include <time.h>
int clock_gettime(clockid_t clock_id, struct timespec *tp);
```
#### 关键参数说明
| 参数        | 作用                                                                 |
|-------------|----------------------------------------------------------------------|
| `clock_id`  | 时间源标识符，指定要获取的时间类型（核心参数，决定时间语义）         |
| `tp`        | 输出参数，指向 `struct timespec` 结构体，用于存储获取到的时间值     |

#### 核心结构体 `struct timespec`
存储时间的精度到**纳秒**，定义如下：
```c
struct timespec {
    time_t tv_sec;   // 秒（seconds）
    long   tv_nsec;  // 纳秒（nanoseconds，范围：0 ~ 999,999,999）
};
```


### 常用 `clock_id` 时间源（核心）
不同 `clock_id` 对应不同语义的时间，需根据场景选择，常见类型如下：

| `clock_id`  | 时间源名称       | 核心特性                                                                 | 典型用途                     |
|-------------|------------------|--------------------------------------------------------------------------|------------------------------|
| `CLOCK_REALTIME` | 系统实时时间     | - 与系统时间同步（可被 `date` 命令或 NTP 服务修改）<br>- 可能因调整而跳变（向前/向后） | 获取当前日历时间（如日志时间戳） |
| `CLOCK_MONOTONIC` | 单调时间         | - 从系统启动后开始计时，**只增不减**（不受系统时间调整影响）<br>- 精度高（纳秒级）     | 计时、性能分析（如函数执行耗时） |
| `CLOCK_PROCESS_CPUTIME_ID` | 进程CPU时间 | - 当前进程占用的 **CPU总时间**（用户态+内核态）<br>- 进程休眠时不增长         | 统计进程实际消耗的CPU资源     |
| `CLOCK_THREAD_CPUTIME_ID` | 线程CPU时间 | - 当前线程占用的 **CPU总时间**<br>- 线程休眠时不增长                          | 统计单个线程的CPU消耗         |

### 关键注意事项
1. **返回值处理**：
   - 成功返回 `0`，失败返回 `-1` 并设置 `errno`（如 `EINVAL` 表示 `clock_id` 无效）。
2. **时间源选择原则**：
   - 计时/性能分析 → 优先 `CLOCK_MONOTONIC`（避免系统时间调整导致结果异常）。
   - 日历时间（如日志）→ 用 `CLOCK_REALTIME`。
   - 统计CPU占用 → 用 `CLOCK_PROCESS_CPUTIME_ID` 或 `CLOCK_THREAD_CPUTIME_ID`。




━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# 相关数据类型
## 1. mqd_t
该数据类型定义在`mqueue.h`中，是用来记录消息队列描述符的。  
```c
typedef int mqd_t;
```  
实质上是`int`类型的别名。

## 2. struct mq_attr
```c
/**
 * @brief 消息队列的属性信息
 * mq_flags 标记，对于mq_open，忽略它，因为这个标记是通过前者的调用传递的
 * mq_maxmsg 队列可以容纳的消息的最大数量
 * mq_msgsize 单条消息的最大允许大小，以字节为单位
 * mq_curmsgs 当前队列中的消息数量，对于mq_open，忽略它
 */
struct mq_attr {
    long mq_flags;    /* Flags (ignored for mq_open()) */
    long mq_maxmsg;   /* Max. # of messages on queue */
    long mq_msgsize;  /* Max. message size (bytes) */
    long mq_curmsgs;  /* # of messages currently in queue
                         (ignored for mq_open()) */
};
```

## 3. struct timespec
```c
/**
 * @brief 时间结构体，提供了纳秒级的UNIX时间戳
 * tv_sec 秒
 * tv_nsec 纳秒
 */
struct timespec {
    time_t tv_sec;     /* seconds */
    long   tv_nsec;    /* nanoseconds */
};
```
