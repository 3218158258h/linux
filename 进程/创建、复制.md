#### `system` 基本用法
```c
#include <stdlib.h>
int system(const char *command);
```
1. `command`：指向字符串的指针，该字符串为要在系统shell中执行的命令（如 `ls -l`、`cmd /c dir`）；若为 `NULL`，则仅检查系统是否支持shell。

#### 返回值
- 成功：返回命令执行后的退出状态（需通过 `WIFEXITED`、`WEXITSTATUS` 等宏解析具体状态）
- 失败（如无法创建子进程、找不到shell）：返回 `-1`
- 若 `command` 为 `NULL`：支持shell返回非0值，不支持返回0

```c
#include <stdlib.h>
#include <stdio.h>
#include <sys/wait.h> // 用于解析返回状态的宏

int main() {
    // 执行系统命令 "ls -l"（Linux/macOS）或 "dir"（Windows）
    int status = system("ls -l");
    
    if (status == -1) {
        perror("system 调用失败");
        return 1;
    }
    
    // 解析命令执行结果
    if (WIFEXITED(status)) {
        printf("命令正常退出，退出码：%d\n", WEXITSTATUS(status));
    } else {
        printf("命令异常终止\n");
    }
    
    return 0;
}
```
- **本质**：通过创建子进程调用系统shell（如 `/bin/sh`），由shell执行指定命令，父进程阻塞等待命令完成。

`======================================================================`

`======================================================================`
#### `fork` 基本介绍
`fork()` 是 **Linux 系统中创建新进程的核心系统调用**，通过“复制当前进程”的方式生成一个新进程（子进程），父子进程共享代码段，但拥有独立的数据段、堆栈和进程ID（PID）。
其函数原型如下（需包含头文件 `<unistd.h>`）：
```c
#include <unistd.h>
pid_t fork(void);
```
#### 核心特性：“一次调用，两次返回”
`fork()` 的特殊之处在于，**调用一次会返回两次**，通过返回值区分父子进程：
- **在父进程中**：返回 **子进程的PID**（一个大于0的整数），用于后续管理子进程（如通过 `wait()` 等待子进程结束）。
- **在子进程中**：返回 **0**，表示自身是新创建的子进程。
- **失败**：返回 **-1**（如系统资源不足、进程数达到上限），且不会创建子进程。
#### 基础示例：通过返回值区分在父/子进程中
```c
#include <unistd.h>
#include <stdio.h>
#include <sys/wait.h> // 用于 wait() 函数

int main() {
    pid_t pid = fork(); // 创建子进程，从此时开始已经有两个进程，后面的代码在两个进程同时运行

    if (pid == -1) {
        perror("fork 失败");  
        return 1;
    } 
    // 子进程逻辑（返回值为0）
    else if (pid == 0) {
        printf("我是子进程，我的PID：%d，父进程PID：%d\n", getpid(), getppid());
        // 子进程执行任务（例：休眠2秒）
        sleep(2);
        printf("子进程执行完毕\n");
    } 
    // 父进程逻辑（返回值为子进程PID）
    else {
        printf("我是父进程，我的PID：%d，子进程PID：%d\n", getpid(), pid);
        // 父进程等待子进程结束，避免子进程成为僵尸进程
        wait(NULL); 
        printf("父进程：子进程已结束\n");
    }

    return 0;
}
```
**输出结果**（PID为示例值，实际会变化）：
```
我是父进程，我的PID：1234，子进程PID：1235
我是子进程，我的PID：1235，父进程PID：1234
子进程执行完毕
父进程：子进程已结束
```
#### 关键概念与注意事项
1. **父子进程的资源共享与独立**
   - **共享**：代码段（执行的指令）、打开的文件描述符（如已打开的文件、网络连接）。
   - **独立**：数据段（全局变量、静态变量）、堆栈（局部变量、函数调用栈）——子进程会复制父进程的这些数据，后续修改互不影响。
2. **僵尸进程（Zombie）问题**
   - 子进程结束后，会保留退出状态等信息，等待父进程通过 `wait()` 或 `waitpid()` 回收。
   - 若父进程未回收且未先退出，子进程会成为“僵尸进程”（状态为 `Z`，可通过 `ps aux` 查看），占用系统PID资源。
   - **解决方式**：父进程主动调用 `wait()`（等待任意子进程）或 `waitpid(pid, &status, 0)`（等待指定PID的子进程）。

`======================================================================`

`======================================================================`
#### `getpid` 基本介绍
`getpid()` 是 **Linux 系统中获取`当前进程`ID（PID）的系统调用**，每个运行中的进程都有唯一的PID，该函数可直接返回当前进程的标识ID，常用于进程管理、日志记录等场景。
```c
#include <unistd.h>
pid_t getpid(void);
```
- 返回值：`pid_t` 类型（本质是整数），代表当前进程的唯一PID。
- 特点：无参数，调用不会失败（只要进程正常运行，就一定有合法PID）。

#### 核心用途与示例
`getpid()` 最常见的场景是**区分进程身份**，尤其在 `fork()` 创建子进程后，结合 `getpid()` 和 `getppid()`（获取父进程PID）可清晰标识父子进程。

##### 基础示例：获取当前进程PID
```c
#include <unistd.h>
#include <stdio.h>
int main() {
    // 获取并打印当前进程（main进程）的PID
    printf("当前进程的PID：%d\n", getpid());
    return 0;
}
```
**输出结果**（PID为系统分配的随机整数，示例值）：
```
当前进程的PID：4567
```

`======================================================================`

`======================================================================`
#### `getppid` 基本介绍
`getppid()` 是 **Linux 系统中获取当前进程“父进程ID（PPID）”的系统调用**，用于定位当前进程的“父进程”（即创建当前进程的进程），与 `getpid()`（获取自身PID）配合使用，可清晰梳理进程间的父子关系。
```c
#include <unistd.h>
pid_t getppid(void);
```
- 返回值：`pid_t` 类型（本质是整数），代表当前进程父进程的唯一PID。
- 特点：无参数，正常运行时不会失败；若父进程已退出，返回值会变为系统“收养进程”的PID（通常是 `1`，即 `init` 或 `systemd` 进程）。
#### 核心用途与示例
`getppid()` 最核心的作用是**确认父进程身份**，尤其在 `fork()` 创建子进程后，子进程可通过它获取父进程PID，或判断父进程是否已退出。
##### 父进程退出后，子进程被“收养”
若父进程先于子进程退出，子进程会成为“孤儿进程”，并被系统进程（如 `init`，PID=1）收养，此时 `getppid()` 返回 `1`：
```c
#include <unistd.h>
#include <stdio.h>
int main() {
    pid_t fork_pid = fork();
    if (fork_pid == 0) {
        printf("子进程初始 - 父进程PID：%d\n", getppid());
        sleep(2); // 等待父进程先退出
        printf("子进程后续 - 父进程PID：%d（已被系统收养）\n", getppid());
    } else if (fork_pid > 0) {
        printf("父进程（PID：%d）即将退出\n", getpid());
        // 父进程不等待子进程，直接退出
    }
    return 0;
}
```
**输出结果**（示例值）：
```
父进程（PID：7890）即将退出
子进程初始 - 父进程PID：7890
子进程后续 - 父进程PID：1（已被系统收养）
```

