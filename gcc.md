###PS
-o指定输出文件名（默认a）
-I指定头文件目录（后面+目录）
-l指定链接某个库文件（后面+库文件）

### 一、编译的概念澄清
广义上的“编译”包含三个阶段：预处理（.c→.i）、编译（狭义，.i→.s，将预处理文件转为汇编语言）、汇编（.s→.o，生成机器码目标文件）；最终通过链接阶段将.o文件组合为可执行文件。


### 二、常用编译选项
#### 1. 基础编译
- **生成可执行文件**：`gcc source.c -o output`（默认生成a.out，-o指定输出文件名）

#### 2. 多阶段控制（对应广义编译流程）
- **预处理（.c→.i）**：`gcc -E source.c -o source.i`（生成预处理文件，展开头文件和宏）
- **编译（狭义，.i→.s）**：`gcc -S source.c -o source.s`（生成汇编文件）
- **汇编（.s→.o）**：`gcc -c source.c -o source.o`（生成目标文件）

#### 3. 警告与调试
- **开启所有警告**：`gcc -Wall source.c`（提示潜在问题，推荐常规使用）
- **生成调试信息**：`gcc -g source.c`（保留调试符号，供gdb调试）

#### 4. 优化与标准
- **代码优化**：`gcc -O2 source.c`（-O1基础优化，-O3最高级优化）
- **指定C标准**：`gcc -std=c99 source.c`（如c99、c11等）

#### 5. 链接选项
- **链接外部库**：`gcc source.c -lm`（-lm链接数学库libm）
- **多文件链接**：`gcc file1.c file2.c -o program`（一次性编译并链接多个源文件）


### 三、各阶段问题与调试
#### 1. 预处理阶段（.c→.i）
- **关键问题**：头文件找不到、宏展开错误、条件编译异常（库文件/宏错误在此阶段）。
- **调试操作**：用`gcc -E`生成.i文件，直接查看头文件是否展开、宏是否正确替换。

#### 2. 编译阶段（.i→.s）
- **关键问题**：语法错误（如少分号）、变量类型不匹配（语法错误主要在此阶段）。
- **调试操作**：用`gcc -S`生成.s文件，通过终端报错定位语法问题；或阅读汇编代码验证逻辑。

#### 3. 汇编阶段（.s→.o）
- **关键问题**：跨平台架构不匹配、汇编指令兼容问题（少见）。
- **调试操作**：用`objdump -f 目标文件.o`查架构；`objdump -d 目标文件.o`反汇编验证机器码。

#### 4. 链接阶段（.o→可执行文件）
- **关键问题**：“undefined reference”（找不到函数实现）、依赖库缺失。
- **调试操作**：用`-lm`等选项链接库；`ldd 可执行文件`查缺失共享库；`nm 目标文件/库`确认符号是否存在。


### 四、调试核心逻辑
根据gcc报错信息定位阶段（如“#include错误”→预处理，“undefined reference”→链接），再用对应阶段的选项（`-E`/`-S`）和工具（`objdump`/`ldd`/`nm`）查看中间产物，逐步缩小问题范围。
# 静态库与动态库
| 对比维度 | 静态库（.a） | 动态库（.so） |
| :--- | :--- | :--- |
| **核心原理** | 编译链接时，将库中所需代码**完整复制**到可执行文件 | 编译链接时仅记录库依赖，程序**运行时动态加载**库文件 |
| **制作工具** | 使用 `ar` 命令打包 `.o` 文件 | 使用 `gcc -shared` 命令生成 |
| **制作关键命令** | `ar crs libxxx.a sub1.o sub2.o ...` | `gcc -shared -o libxxx.so sub1.o sub2.o ...`（交叉编译需加 `-fPIC`） |
| **链接命令** | 直接指定静态库路径：<br>`gcc -o 可执行文件 main.o libxxx.a`（或指定路径 `./libxxx.a`） | 需用 `-l` 指定库名、`-L` 指定库路径：<br>`gcc -o 可执行文件 main.o -lxxx -L 库所在目录` |
| **运行依赖** | 可执行文件**不依赖原静态库**，可独立运行 | 程序运行时必须找到对应的 `.so` 文件（需配置 `LD_LIBRARY_PATH` 或放入系统库目录） |
| **文件体积** | 可执行文件体积**较大**（包含库代码） | 可执行文件体积**较小**（仅含库引用） |
| **更新维护** | 库更新后，需**重新编译链接**生成新可执行文件 | 库更新后，直接替换 `.so` 文件即可，无需重新编译可执行文件 |
#### 制作、使用动态库
#### 第1步：制作与编译
1. 编译源文件生成目标文件（`.o`）  
   ```bash
   gcc -c -o main.o main.c   # 编译主程序源文件
   gcc -c -o sub.o sub.c     # 编译动态库依赖的源文件（可多个）
   # 若有其他依赖文件（如sub2.c、sub3.c），需分别编译：
   # gcc -c -o sub2.o sub2.c
   # gcc -c -o sub3.o sub3.c
   ```
2. 生成动态库（`.so`）  
   ```bash
   gcc -shared -o libsub.so sub.o sub2.o sub3.o  # 多个.o文件生成动态库
  ```
- **`gcc`**：GNU编译器集合，此处用于编译生成动态库
- **`-shared`**：核心选项，指定生成动态链接库（而非可执行文件或静态库）
- **`-o libsub.so`**：`-o`指定输出文件名为`libsub.so`（动态库命名规范：以`lib`为前缀，`.so`为后缀）
- **`sub.o sub2.o sub3.o`**：作为输入的目标文件（可多个），这些文件会被合并到动态库中
3. 链接动态库生成可执行文件  
   ```bash
   gcc -o test main.o -lsub -L /path/to/libsub.so  # -L指定动态库所在目录，-l指定库名（省略lib前缀和.so后缀）
   ```
#### 第2步：运行可执行文件
##### 方式1：将动态库放入系统默认库目录
```bash
# 将动态库复制到系统库目录（需管理员权限）
sudo cp libsub.so /lib  
# 直接运行可执行文件
./test
```
#### 方式2：指定动态库搜索路径（无需复制到系统目录）
```bash
# 临时添加动态库路径到环境变量（仅当前终端生效）
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/libdir  # /path/to/libdir 为libsub.so所在目录（如/a）
# 运行可执行文件
./test
```
#### 制作、使用静态库
#### 第1步：制作与编译
1. 编译源文件生成目标文件（`.o`）  
   ```bash
   gcc -c -o main.o main.c   # 编译主程序源文件
   gcc -c -o sub.o sub.c     # 编译静态库依赖的源文件（可多个）
   # 若有其他依赖文件（如sub2.c、sub3.c），需分别编译：
   # gcc -c -o sub2.o sub2.c
   # gcc -c -o sub3.o sub3.c
   ```
2. 生成静态库（`.a`）  
   ```bash
   ar crs libsub.a sub.o sub2.o sub3.o  # 多个.o文件生成静态库（c创建、r插入、s建立索引）
   ```
3. 链接静态库生成可执行文件  
   ```bash
   # 若静态库在当前目录：
   gcc -o test main.o libsub.a  
   # 若静态库不在当前目录，需指定路径（绝对/相对）：
   # gcc -o test main.o /path/to/libsub.a
   ```
### 第2步：运行可执行文件
静态库会被**直接嵌入到可执行文件中**，运行时无需依赖外部静态库，直接执行即可：
```bash
./test
```
### 注意事项（交叉编译场景）
使用交叉编译器（如`arm-buildroot-linux-gnueabihf-gcc`）编译目标文件时，需添加`-fPIC`参数（生成位置无关代码），示例：
```bash
arm-buildroot-linux-gnueabihf-gcc -c -fPIC -o sub.o sub.c
```
