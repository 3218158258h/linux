## 无名信号量
### 定义
```c
sem_t  sem;
```
### 初始化
`sem_init()` 用于初始化信号量的函数
```c
#include <semaphore.h>
int sem_init(sem_t *sem, int pshared, unsigned int value);
```
### 参数解析
- `sem`：指向 `sem_t` 类型信号量对象的指针，用于存储初始化后的信号量
- `pshared`：指定信号量的共享范围
  - `0`：信号量用于**同一进程内的线程间同步**
  - 非 `0`：信号量用于**多个进程间同步**（需位于共享内存中）
- `value`：信号量的初始值，决定了可同时访问共享资源的线程/进程数量
### 返回值
- 成功：返回 `0`
- 失败：返回 `-1`，并设置 `errno` 表示错误原因（如 `EINVAL` 表示参数无效）
### 关键特性
1. **信号量值的含义**：`value` 表示可同时访问共享资源的最大数量。当信号量值为 `0` 时，后续 `sem_wait()` 调用会阻塞；当值为 `1` 时，信号量退化为互斥锁（二元信号量）。

2. **共享范围**：
   - 线程间同步（`pshared=0`）：信号量可直接声明为全局变量或堆变量
   - 进程间同步（`pshared≠0`）：信号量必须位于共享内存区域（如通过 `shm_open` 创建）
```c
      char *shm_sem_name = "unnamed_sem_shm_sem";
    // 创建内存共享对象
    int sem_fd = shm_open(shm_sem_name, O_CREAT | O_RDWR, 0666);
    // 调整内存共享对象的大小
    ftruncate(sem_fd, sizeof(sem_t));
    // 将内存共享对象映射到共享内存区域
    sem_t *sem = mmap(NULL, sizeof(sem_t), PROT_READ | PROT_WRITE, MAP_SHARED, sem_fd, 0);
    // 初始化信号量和共享变量的值
    sem_init(sem, 1, 1);
 ```

3. **与其他信号量函数的配合**：
   - `sem_wait()`：获取信号量（P操作，信号量值减1，若为0则阻塞）
   - `sem_post()`：释放信号量（V操作，信号量值加1，唤醒等待线程）
   - `sem_destroy()`：销毁信号量，释放资源

### 注意事项
1. **线程间通信，pshared必须设置为0**
2. **进程间通信，pshared必须设置为非0，如1**
3. **进程间通信，必须定义在共享空间**


### 等待(P操作)
`sem_wait` 用于获取信号量，对应信号量操作中的“P 操作”（获取资源），它会尝试减少信号量的值。
减少后，若信号量值为 0 则阻塞等待，直到信号量值大于 0 为止。
```c
#include <semaphore.h>

int sem_wait(sem_t *sem);
```
### 功能与行为
- 将信号量的值 **原子性地减 1**（`sem->value -= 1`）
- 若操作前信号量的值 **大于 0**，操作后直接返回（成功获取资源）
- 若操作前信号量的值 **等于 0**，当前线程/进程会 **阻塞等待**，直到其他线程/进程通过 `sem_post` 增加信号量的值（释放资源）
- 阻塞期间不消耗 CPU 资源，直到被唤醒或发生错误
### 返回值
- 成功获取信号量：返回 `0`
- 失败：返回 `-1`，并设置 `errno` 表示错误原因（如 `EINVAL` 表示信号量无效，`EINTR` 表示被信号中断）
### 变体函数
- `sem_trywait`：非阻塞版本，若信号量为 0 则直接返回 `EBUSY` 错误，不阻塞
- `sem_timedwait`：限时等待版本，若超时仍未获取信号量则返回 `ETIMEDOUT`

### 关键特性
1. **原子性**：对信号量值的修改是原子操作，避免多线程同时操作导致的竞态条件
2. **阻塞等待**：当资源不可用时（信号量为 0），自动阻塞线程，不占用 CPU 资源
3. **唤醒响应**：被 `sem_post` 唤醒后，会立即重新尝试获取信号量（无需手动重试）
4. **死锁风险**：若线程获取信号量后未释放（如异常退出），会导致其他线程永久阻塞


### 唤醒(其他线/进程)V操作
`sem_post` 是 用于释放信号量的函数，对应信号量操作中的“V 操作”（释放资源），它会增加信号量的值并唤醒可能阻塞在该信号量上的线程或进程。
```c
#include <semaphore.h>

int sem_post(sem_t *sem);
```
### 功能与行为
- 将信号量的值 **原子性地加 1**（`sem->value += 1`）
- 若有线程/进程因调用 `sem_wait` 而阻塞等待该信号量，`sem_post` 会唤醒其中至少一个等待者（具体唤醒哪个由系统调度决定）
- 信号量的值增加后可以超过其初始值（无上限，除非系统定义了 `SEM_VALUE_MAX` 限制）

### 返回值
- 成功：返回 `0`
- 失败：返回 `-1`，并设置 `errno` 表示错误原因（如 `EINVAL` 表示信号量无效，`EOVERFLOW` 表示信号量值溢出）

### 关键特性
1. **原子操作**：`sem_post` 对信号量值的修改是原子的，避免了多线程同时操作导致的竞态条件
2. **唤醒机制**：每次调用至少唤醒一个等待线程（若有），确保等待者能及时响应资源释放
3. **与 `sem_wait` 配对**：`sem_post` 通常与 `sem_wait` 配合使用，分别对应“释放资源”和“获取资源”


### 销毁
`sem_destroy` 是 用于销毁信号量的函数，主要作用是释放信号量所占用的系统资源
```c
#include <semaphore.h>
int sem_destroy(sem_t *sem);
```
### 功能与行为
- 销毁一个已通过 `sem_init` 初始化的信号量，释放其关联的内核资源（如等待队列等）
- 销毁后，信号量变为未初始化状态，若需再次使用必须重新调用 `sem_init` 初始化
- 若对正在被线程/进程等待的信号量（即有线程阻塞在 `sem_wait` 上）调用 `sem_destroy`，行为是**未定义的**（可能导致程序崩溃或资源泄漏）
### 返回值
- 成功：返回 `0`
- 失败：返回 `-1`，并设置 `errno`（如 `EINVAL` 表示信号量未初始化或已销毁）

### 关键注意事项
1. **销毁时机**：必须在所有线程/进程都已完成对该信号量的操作（即没有线程阻塞在 `sem_wait` 上），且后续不再使用时调用
2. **资源释放**：不销毁信号量会导致系统资源泄漏，尤其在长期运行的服务程序中需特别注意
3. **重复操作**：对未初始化或已销毁的信号量调用 `sem_destroy` 会返回错误（`EINVAL`）
4. **进程间共享信号量**：若信号量用于多进程同步（`sem_init` 的 `pshared` 参数非 0），需确保所有使用它的进程都结束后再销毁，通常由最后一个退出的进程执行销毁操作


## 有名信号量
### 创建
`sem_open` 是=用于创建或打开信号量的函数，与 `sem_init` 不同，它支持跨进程同步，通过文件系统路径标识信号量。
```c
#include <semaphore.h>

sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);
```
- `name`：信号量的唯一标识路径（通常以 `/` 开头，如 `/my_sem`），需符合文件系统命名规则
- `oflag`：打开方式，常用组合：
  - `O_CREAT`：若信号量不存在则创建
  - `O_EXCL`：与 `O_CREAT` 结合使用，若信号量已存在则返回错误
  - `O_RDWR`：读写权限（默认）
- `mode`：当 `O_CREAT` 被指定时，设置信号量的权限位（如 `0644`），否则忽略
- `value`：当 `O_CREAT` 被指定时，设置信号量的初始值，否则忽略

#### 返回值
- 成功：返回指向 `sem_t` 类型的信号量指针
- 失败：返回 `SEM_FAILED`，并设置 `errno` 表示错误原因

#### 关键特性
1. **跨进程共享**：通过文件系统路径标识，可被多个进程访问（需有对应权限）
2. **持久性**：命名信号量独立于进程存在，即使所有进程关闭它，仍会保留在系统中，需通过 `sem_unlink` 手动删除
3. **与无名信号量的区别**：
   - 无名信号量（`sem_init` 创建）：仅用于线程间或共享内存中的进程间同步
   - 命名信号量（`sem_open` 创建）：通过文件系统持久化，适合任意进程间同步

#### 配套函数
- `sem_close`：关闭信号量（进程不再使用，但信号量本身仍存在）
- `sem_unlink`：删除信号量的文件系统标识（彻底销毁，需所有进程关闭后生效）

#### 注意事项
1. **命名规则**：`name` 通常以 `/` 开头，避免与文件系统中其他文件冲突
2. **权限设置**：`mode` 参数需合理设置，确保相关进程有访问权限
3. **资源清理**：不再需要时必须调用 `sem_unlink` 删除，否则会残留系统中
4. **移植性**：不同系统对命名信号量的实现可能不同（如存储路径），需注意兼容性


### 关闭引用
`sem_close` 是 POSIX 命名信号量机制中用于关闭信号量的函数，它负责释放当前进程对命名信号量的引用，但不会直接删除信号量本身（信号量仍存在于系统中，可被其他进程访问）。
```c
#include <semaphore.h>
int sem_close(sem_t *sem);
```

- 关闭当前进程与命名信号量的关联，释放进程内与该信号量相关的资源（如文件描述符、内部数据结构）
- 关闭后，当前进程不能再对该信号量执行 `sem_wait`、`sem_post` 等操作，否则行为未定义
- 信号量本身不会被销毁，其他进程仍可通过 `sem_open` 打开并使用它
- 若进程退出时未调用 `sem_close`，系统会自动关闭其持有的所有信号量（但显式调用是良好实践）

#### 返回值
- 成功：返回 `0`
- 失败：返回 `-1`，并设置 `errno` 表示错误原因（如 `EINVAL` 表示信号量指针无效）

#### 关键特性
1. **进程级释放**：`sem_close` 仅影响当前进程对信号量的引用，不影响其他进程
2. **与 `sem_unlink` 的区别**：
   - `sem_close`：关闭当前进程的信号量引用（类似关闭文件描述符）
   - `sem_unlink`：删除信号量的系统级标识（类似删除文件），需所有进程关闭后才彻底销毁
3. **引用计数**：系统会为命名信号量维护引用计数，当最后一个进程调用 `sem_close` 后，信号量的内核资源才会被部分释放（但标识仍存在，直到 `sem_unlink` 被调用）

#### 注意事项
1. **关闭后不可操作**：对已关闭的信号量指针执行任何操作（如 `sem_wait`），行为未定义（可能导致崩溃）
2. **资源泄漏**：长期运行的进程若频繁打开信号量而不关闭，会导致进程内资源（如文件描述符）泄漏
3. **配合 `sem_unlink` 使用**：若要彻底移除信号量，需在所有进程关闭后调用 `sem_unlink`，否则信号量会残留于系统中

### 彻底移除
`sem_unlink` 是 删除信号量标识的函数，它会移除信号量在文件系统中的名字，确保信号量在所有进程关闭后被彻底销毁，避免系统资源残留。
```c
#include <semaphore.h>
int sem_unlink(const char *name);
```
### 功能与行为
- 删除命名信号量的唯一标识（`name` 所指定的路径），使其无法被新进程通过 `sem_open` 打开
- 不会立即销毁信号量本身：若仍有进程持有该信号量的引用（未调用 `sem_close`），信号量会继续存在，直到最后一个进程关闭它

### 返回值
- 成功：返回 `0`
- 失败：返回 `-1`，并设置 `errno` 表示错误原因（如 `ENOENT` 表示信号量不存在，`EACCES` 表示权限不足）

### 关键特性
1. **标识删除**：仅移除信号量的文件系统标识，不直接终止正在使用信号量的进程
2. **延迟销毁**：信号量的内核资源会在最后一个引用它的进程调用 `sem_close` 后才彻底释放
3. **不可恢复**：一旦删除，无法通过原名称恢复信号量，需重新创建

### 注意事项
1. **删除时机**：通常由最后一个使用信号量的进程调用，确保所有进程都已完成操作
2. **权限要求**：调用进程需对信号量的命名路径有写权限
3. **残留处理**：若进程在使用信号量时异常退出未调用 `sem_unlink`，信号量会残留，需手动删除（如通过 `rm` 命令删除 `/dev/shm` 下的对应文件，具体路径因系统而异）

###
1. **关于“进程间通信方式通常可用于线程间通信”**  
   进程间通信（IPC）机制（如信号量、共享内存、消息队列）大多可用于线程间通信，因为线程共享进程地址空间，天然具备“可见性”基础。但反之不成立（线程间通信方式如全局变量，无法直接用于进程间）。


2. **无名与有名信号量的进程间通信差异**  
   - 有名信号量通过文件系统路径（如`/my_sem`）全局唯一标识，无需额外共享内存，适用于无关联的进程（如独立程序）。  
   - 无名信号量依赖共享内存（如`mmap`或`shmget`创建的区域）实现进程间可见，其“共享”本质是通过内存区域的唯一标识（而非信号量自身名称）实现的，更适合有共享内存基础的进程（如父子进程）。


3. **二进制与计数信号量的通用性**  
   无论是有名还是无名信号量，均可通过初始值设置为“二进制信号量”（初始值1，实现互斥）或“计数信号量”（初始值N>1，控制N个并发访问），灵活性高。


4. **二进制与计数信号量的功能差异**  
   核心区别不仅是取值范围：  
   - 二进制信号量（0/1）：本质是互斥锁，保证同一时间只有一个线程/进程访问资源（如临界区保护）。  
   - 计数信号量（≥0）：控制资源访问数量（如限制5个线程同时读取文件）或协调执行顺序（如生产者生产N个数据后消费者才能读取）。  


5. **信号量的核心作用是“同步”而非“传数据”**  
   信号量通过控制“资源可用数量”或“执行条件”实现协同，本身不携带数据。若需传输数据，需配合共享内存、消息队列等机制。


6. **信号量的选择原则**  
   - 进程间：有名信号量无需手动管理共享内存，编码更简单（避免处理内存共享的细节）。  
   - 线程间：无名信号量通过全局变量即可共享，无需文件系统交互，效率更高。  


7. **跨进程信号量的资源管理风险**  
   - 有名信号量需确保`sem_unlink`在所有进程退出后调用，否则会残留系统（如`/dev/shm`下的文件）。  
   - 无名信号量依赖的共享内存需按“创建→使用→销毁”顺序操作，避免某进程提前释放内存导致其他进程访问失效。  


