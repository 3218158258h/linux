### 互斥锁
#### 一般流程
- 定义(pthread_mutex_t lock)：定义一个锁lock
- 初始化（pthread_mutex_init）：创建互斥锁并初始化。
- 锁定（pthread_mutex_lock）：获取互斥锁。如果锁已经被其他线程持有则阻塞等待。
- 尝试锁定（pthread_mutex_trylock）：尝试获取互斥锁。如果锁已被持有，立即返回而不是阻塞。
- 解锁（pthread_mutex_unlock）：释放互斥锁，使其可被其他线程获取。
- 销毁（pthread_mutex_destroy）：清理互斥锁资源。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
### 1-1.静态初始化
```c
static pthread_mutex_t counter_mutex = PTHREAD_MUTEX_INITIALIZER;
```
- `直接定义`并初始化，仅在当前函数有效

### 1-2.动态初始化
`pthread_mutex_init`负责为互斥锁分配资源并设置其属性，是使用互斥锁前的必要操作。
```c
#include <pthread.h>
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
```
- **必须销毁**：动态初始化的互斥锁使用后必须用 `pthread_mutex_destroy` 释放资源

##### 参数解析
- `mutex`：指向 `pthread_mutex_t` 类型变量的指针，用于存储初始化后的互斥锁
- `attr`：互斥锁的属性设置，为 `NULL` 时表示使用默认属性
##### 返回值
- 成功：返回 `0`
- 失败：返回非零错误码（如 `ENOMEM` 表示内存不足，`EBUSY` 表示锁已初始化）
##### 1. 默认属性初始化（最常用）
```c
//定义互斥锁
pthread_mutex_t mutex;
// 初始化互斥锁，使用默认属性
if (pthread_mutex_init(&mutex, NULL) != 0) {
    perror("Failed to initialize mutex");
    exit(EXIT_FAILURE);
}
// 使用互斥锁...
// 销毁互斥锁（必须调用）
pthread_mutex_destroy(&mutex);
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
### 2-1.获取锁
`pthread_mutex_lock` 是 POSIX 线程库中用于获取互斥锁的核心函数，若锁已经被获取则阻塞等待
```c
#include <pthread.h>
int pthread_mutex_lock(pthread_mutex_t *mutex);
```
##### 返回值
- 成功获取锁：返回 `0`
- 失败：返回非零错误码（如 `EDEADLK` 表示检测到死锁，仅错误检查锁会返回此值）
##### 使用示例
```c
#include <stdio.h>
#include <pthread.h>
int shared_counter = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // 定义并静态初始化

void *thread_func(void *arg) {
    for (int i = 0; i < 10000; i++) {
        // 获取锁（若已被锁定则阻塞等待）
        if (pthread_mutex_lock(&mutex) != 0) {
            perror("lock failed");
            return NULL;
        }
        // 临界区：安全访问共享资源
        shared_counter++;
        // 释放锁
        pthread_mutex_unlock(&mutex);
    }
    return NULL;
}
```
##### 关键注意事项
1. **配对使用**：`pthread_mutex_lock` 必须与 `pthread_mutex_unlock` 配对使用，否则会导致死锁
2. **锁粒度**：临界区应尽可能小（只包含必要的共享资源操作），减少线程等待时间，提高并发效率

### 2-2.尝试获取锁
`pthread_mutex_trylock` 与 `pthread_mutex_lock` 的阻塞等待不同，它会尝试获取锁并立即返回结果，不会让线程进入阻塞状态。
```c
#include <pthread.h>

int pthread_mutex_trylock(pthread_mutex_t *mutex);
```
##### 功能与行为
- 当互斥锁处于**未锁定状态**时，会立即锁定互斥锁并返回 `0`（成功获取锁）
- 当互斥锁已被**其他线程锁定**时，不会阻塞等待，而是立即返回 `EBUSY` 错误码
- 若对**非递归锁**进行重复加锁（同一线程已持有该锁）：
  - 普通锁（`PTHREAD_MUTEX_NORMAL`）可能导致未定义行为
  - 错误检查锁（`PTHREAD_MUTEX_ERRORCHECK`）会返回 `EDEADLK`

##### 返回值
- `0`：成功获取互斥锁
- `EBUSY`：互斥锁已被其他线程持有，无法获取
- `EDEADLK`：检测到死锁（仅错误检查锁会返回）
- 其他非零错误码：其他错误情况（如锁未初始化）
##### 使用示例
```c
#include <stdio.h>
#include <pthread.h>
#include <errno.h>
int shared_resource = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
void *thread_func(void *arg) {
    int retries = 0;
    while (retries < 5) { // 最多重试5次
        // 尝试获取锁（非阻塞）
        int ret = pthread_mutex_trylock(&mutex);
        if (ret == 0) {
            // 成功获取锁，执行临界区操作
            shared_resource++;
            printf("线程 %ld 成功更新资源\n", (long)arg);
            
            // 释放锁
            pthread_mutex_unlock(&mutex);
            break;
        } else if (ret == EBUSY) {
            // 锁被占用，稍等后重试
            printf("线程 %ld 重试获取锁...\n", (long)arg);
            retries++;
            usleep(100000); // 休眠100ms
        } else {
            // 其他错误
            perror("trylock failed");
            break;
        }
    }
    return NULL;
}
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
### 3.释放锁
`pthread_mutex_unlock` 是 POSIX 线程库中用于释放互斥锁的函数，它与 `pthread_mutex_lock` 或 `pthread_mutex_trylock` 配对使用，用于解除对互斥锁的占用，允许其他线程获取该锁并进入临界区。

##### 函数原型
```c
#include <pthread.h>

int pthread_mutex_unlock(pthread_mutex_t *mutex);
```
##### 返回值
- 成功释放锁：返回 `0`
- 失败：返回非零错误码（如 `EPERM` 表示调用线程不是锁的持有者）

##### 使用示例
```c
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
int shared_value = 0;
pthread_mutex_t mutex;
void *thread_work(void *arg) {
    // 获取锁
    if (pthread_mutex_lock(&mutex) != 0) {
        perror("lock failed");
        return NULL;
    }
    
    // 临界区操作
    shared_value += *(int *)arg;
    printf("线程 %ld 更新后的值: %d\n", pthread_self(), shared_value);
    
    // 释放锁
    if (pthread_mutex_unlock(&mutex) != 0) {
        perror("unlock failed");
        return NULL;
    }
    
    return NULL;
}

int main() {
    pthread_t t1, t2;
    int val1 = 5, val2 = 3;
    
    // 动态初始化互斥锁
    if (pthread_mutex_init(&mutex, NULL) != 0) {
        perror("mutex init failed");
        exit(EXIT_FAILURE);
    }
    
    pthread_create(&t1, NULL, thread_work, &val1);
    pthread_create(&t2, NULL, thread_work, &val2);
    
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    
    printf("最终结果: %d\n", shared_value); // 应输出 8
    
    // 销毁互斥锁
    pthread_mutex_destroy(&mutex);
    return 0;
}
```
##### 关键注意事项
1. **配对原则**：每个 `pthread_mutex_lock` 或 `pthread_mutex_trylock`（成功获取锁时）必须对应一个 `pthread_mutex_unlock`，否则会导致锁永远无法释放（死锁）
2. **持有者检查**：只有获取锁的线程才能释放它，其他线程释放会导致未定义行为（错误检查锁会返回 `EPERM` 错误）
3. **递归锁处理**：对于递归锁（`PTHREAD_MUTEX_RECURSIVE`），需要解锁相同次数的加锁操作才能真正释放锁（例如加锁3次，需解锁3次）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
### 4.销毁锁
`pthread_mutex_destroy` 是 POSIX 线程库中用于销毁互斥锁的函数
```c
#include <pthread.h>
int pthread_mutex_destroy(pthread_mutex_t *mutex);
```

### 功能与行为
- 销毁一个已初始化的互斥锁，释放其关联的资源
- 销毁后，互斥锁变为未初始化状态，若需再次使用必须重新初始化
- 若销毁一个正在被线程持有的互斥锁，行为是**未定义的**（可能导致程序崩溃或死锁）

### 返回值
- 成功：返回 `0`
- 失败：返回非零错误码（如 `EBUSY` 表示锁正被使用，`EINVAL` 表示锁未初始化）


### 关键注意事项
1. **销毁时机**：必须在互斥锁不再被任何线程使用时销毁（确保已解锁且后续无线程会访问）
2. **与初始化配对**：动态初始化（`pthread_mutex_init`）的互斥锁必须用此函数销毁，静态初始化（`PTHREAD_MUTEX_INITIALIZER`）的锁无需手动销毁
3. **重复销毁**：销毁一个未初始化或已销毁的互斥锁，行为是未定义的
4. **资源释放**：不销毁动态初始化的互斥锁会导致资源泄漏，长期运行的程序中需特别注意
5. **多进程共享锁**：对于进程间共享的互斥锁，通常需要在所有使用它的进程都销毁后才真正释放资源


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
## 条件变量
#### 一般流程
- 定义(pthread_cond_t cond)：定义一个条件变量cond
- 初始化（pthread_cond_init）：创建读写锁并初始化。
- 等待（pthread_cond_wait或pthread_cond_timedwait）：给互斥锁上等待条件变量(后者有等待时间限度)
- 唤醒（pthread_cond_signal或pthread_cond_broadcast）：唤醒至少一个/所有等待该条件变量的线程
- 销毁（pthread_cond_destroy）：清理条件变量(静态初始化不需要)

### 初始化
```c
static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;//静态初始化
```
```c
#include <pthread.h>
int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);//动态初始化 attr一般是NULL
```
### 等待
```c
pthread_cond_wait(&cond, &mutex);//阻塞等待，mutex是互斥锁
```
```c
#include <pthread.h>
#include <time.h>  // 需包含time.h以使用struct timespec
//abstime要提前定义。具体参考消息队列的的clock_gettime()
int pthread_cond_timedwait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex,const struct timespec *restrict abstime);
```
### 唤醒
```c
pthread_cond_signal(&cond);//随机唤醒一个线程的互斥锁
```
```c
#include <pthread.h>
int pthread_cond_broadcast(pthread_cond_t *cond);//唤醒所有线程的互斥锁
```
### 销毁
```c
pthread_cond_destroy(&cond);
```



