### 读写锁
#### 一般流程
- 定义(pthread_rwlock_t rwlock)：定义一个锁rwlock
- 初始化（pthread_rwlock_init）：创建读写锁并初始化。
- 获取读/写锁（pthread_rwlock_rdlock或者pthread_rwlock_wrlock）：获取读/写锁。
- 解锁（pthread_rwlock_unlock）：释放读写锁，使其可被其他线程获取。
- 销毁（pthread_rwlock_destroy）：清理读写锁资源。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
### 静态初始化
```c
pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;
```
`静态初始化也要销毁`
`自动定义并初始化`

### 动态初始化
`pthread_rwlock_init` 是 POSIX 线程库中用于初始化读写锁（Reader-Writer Lock）的函数。读写锁是一种更灵活的同步机制，允许多线程可以共享读权限，而写操作则需要独占访问，适用于读多写少的场景。

```c
#include <pthread.h>
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);
```
#### 参数说明
- `rwlock`：指向要初始化的 `pthread_rwlock_t` 类型变量的指针
- `attr`：读写锁的属性设置，`NULL` 表示使用默认属性
#### 返回值
- 成功：返回 `0`
- 失败：返回非零错误码（如 `ENOMEM` 表示内存不足）
#### 读写锁特性
- **读共享**：多个线程可以同时获取读锁（`pthread_rwlock_rdlock`）
- **写独占**：写锁（`pthread_rwlock_wrlock`）会阻塞所有读锁和其他写锁
- **优先级**：默认情况下，写操作可能会被大量读操作"饿死"，可通过属性设置调整优先级


### 注意事项
1. 读写锁使用完毕后必须用 `pthread_rwlock_destroy` 销毁
2. 初始化后的读写锁不能重复初始化，除非先销毁
3. 静态初始化方式：`pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;`

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
### 获取读写锁
`pthread_rwlock_rdlock` 是 POSIX 线程库中用于获取读写锁读权限的函数，它允许多个线程同时获取读锁以共享访问资源，适用于读取共享数据的场景。
```c
#include <pthread.h>

int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
```

#### 功能与行为
- 当读写锁处于**未锁定状态**或**已被其他线程持有读锁**时，调用线程会获取读锁，函数返回 `0`
- 当读写锁已被**其他线程持有`写`锁**时，当前线程会**阻塞等待**，直到写锁被释放
- 若当前线程已持有**写锁**，调用此函数的行为是**未定义的**（可能导致死锁）
- 若当前线程已持有**读锁**，多数实现允许重复获取（类似递归锁），但释放时需对应次数的解锁

#### 返回值
- 成功获取读锁：返回 `0`
- 失败：返回非零错误码（如 `EDEADLK` 表示检测到死锁，`EBUSY` 表示非阻塞模式下无法获取）

#### 关键特性
1. **读共享**：多个线程可同时持有读锁，提高读操作的并发效率
2. **阻塞写操作**：持有读锁时，写线程会被阻塞（直到所有读锁释放）
3. **非阻塞版本**：`pthread_rwlock_tryrdlock` 可尝试获取读锁而不阻塞，失败时返回 `EBUSY`

#### 注意事项
1. **与写锁的交互**：读锁会阻塞写锁，大量读操作可能导致写操作"饿死"，部分系统可通过属性设置写优先级
2. **解锁配对**：每个 `pthread_rwlock_rdlock` 必须对应一个 `pthread_rwlock_unlock`，否则会导致锁泄漏


`pthread_rwlock_wrlock` 确保只有一个线程能获取写锁以独占方式访问资源，适用于修改共享数据的场景。
```c
#include <pthread.h>

int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
```
#### 功能与行为
- 当读写锁处于**未锁定状态**时，调用线程会获取写锁，函数返回 `0`
- 当读写锁已被**其他线程持有读锁或写锁**时，当前线程会**阻塞等待**，直到所有锁（读锁和写锁）都被释放
- 若当前线程已持有**读锁或写锁**，调用此函数的行为是**未定义的**（通常会导致死锁）
#### 返回值
- 成功获取写锁：返回 `0`
- 失败：返回非零错误码（如 `EDEADLK` 表示检测到死锁，`EBUSY` 表示非阻塞模式下无法获取）
#### 关键特性
1. **写独占**：同一时间只能有一个线程持有写锁，确保数据修改的原子性
2. **阻塞所有**：获取写锁时会阻塞所有读线程和其他写线程，直到写锁释放
3. **非阻塞版本**：`pthread_rwlock_trywrlock` 可尝试获取写锁而不阻塞，失败时返回 `EBUSY`
4. **写饥饿问题**：如果读操作非常频繁，写线程可能长期等待（"饥饿"），部分系统可通过设置读写锁属性（如写优先级）缓解

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
### 释放读写锁
`pthread_rwlock_unlock` 与 `pthread_rwlock_rdlock`（读锁）或 `pthread_rwlock_wrlock`（写锁）配对使用，用于解除对读写锁的占用，允许其他线程获取锁。
```c
#include <pthread.h>
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
```
#### 功能与行为
- 若当前线程持有**读锁**，调用该函数会释放一个读锁计数。当所有读锁都被释放后，等待的写线程才有机会获取写锁。
- 若当前线程持有**写锁**，调用该函数会释放写锁，此时等待的读线程或写线程会被唤醒（具体唤醒哪类线程取决于系统实现和锁属性）。
- 释放一个未被当前线程持有的读写锁，行为是**未定义的**（可能导致程序崩溃或死锁）。

#### 返回值
- 成功释放锁：返回 `0`
- 失败：返回非零错误码（如 `EPERM` 表示当前线程不是锁的持有者）
### 关键特性
1. **通用释放**：同一个函数可释放读锁或写锁，无需区分锁类型（内部会根据锁的当前状态处理）。
2. **唤醒策略**：
   - 释放写锁后，系统可能优先唤醒等待的写线程（避免写饥饿）或唤醒所有读线程（提高读并发），具体取决于实现。
   - 释放读锁后，只有当所有读锁都被释放时，才会唤醒等待的写线程。
 **配对原则**：每个成功的 `pthread_rwlock_rdlock` 或 `pthread_rwlock_wrlock` 必须对应一个 `pthread_rwlock_unlock`，否则会导致锁永久占用（死锁）。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`pthread_rwlock_destroy` 用于销毁读写锁的函数，负责释放读写锁所占用的系统资源，是读写锁生命周期管理的收尾操作。
```c
#include <pthread.h>
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
```
#### 返回值
- 成功：返回 `0`
- 失败：返回非零错误码（如 `EBUSY` 表示锁正被使用，`EINVAL` 表示锁未初始化）
#### 关键注意事项
1. **销毁时机**：必须在所有线程都已释放该读写锁，且后续不再有线程访问时销毁
2. **与初始化配对**：
   - 动态初始化（`pthread_rwlock_init`）的读写锁必须用此函数销毁
   - 静态初始化（`PTHREAD_RWLOCK_INITIALIZER`）的读写锁也需要销毁（即使是 `static` 修饰的）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
### 写饥饿问题
- 当读操作远多于写操作时，读写锁会持续被读线程占用（多个读线程可同时持有读锁），

  导致写线程长期处于阻塞状态，无法获取写锁，形成 "写饥饿"。
- 解决方法：提升获取写锁的权限，写锁阻塞等待时无法获取读锁

- 1.定义读写锁属性对象
- 2.初始化读写锁属性对象
- 3.配置属性对象优先级
- 4.用自定义属性对象初始化读写锁
- 5.销毁读写锁属性对象

### 解决写饥饿问题
1. **声明属性对象和读写锁**  
   ```c
   pthread_rwlockattr_t attr;  // 读写锁属性对象
   pthread_rwlock_t rwlock;    // 读写锁
   ```
2. **初始化属性对象**  
   调用 `pthread_rwlockattr_init` 为属性对象设置默认值：  
   ```c
   if (pthread_rwlockattr_init(&attr) != 0) {
       // 错误处理（如打印错误信息）
   }
   ```
3. **设置写优先属性**  
   通过 `pthread_rwlockattr_setkind_np` 配置"写优先"策略，避免写饥饿：  
   ```c
   // 设置为有效写优先模式（避免写线程饥饿）
   if (pthread_rwlockattr_setkind_np(&attr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP) != 0) {
       // 错误处理
   }
   ```

4. **用自定义属性初始化读写锁**  
   将配置好的属性应用到读写锁：  
   ```c
   if (pthread_rwlock_init(&rwlock, &attr) != 0) {
       // 错误处理
   }
   ```
5. **销毁属性对象**  
   属性对象完成使命后释放资源：  
   ```c
   pthread_rwlockattr_destroy(&attr);  // 即使失败也通常无需特殊处理
   ```

### 核心逻辑
通过配置 `PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP` 属性，确保当有写线程等待时，新的读线程会被阻塞，直到写线程完成操作，从而平衡读写公平性，解决写饥饿问题。


