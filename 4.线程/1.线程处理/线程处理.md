### 线程被创建后必须通过pthread_join或pthread_detach释放内核资源，否则会成为僵尸线程

#### `pthread_create`（创建线程函数）
`pthread_create` 是 POSIX 线程（pthread）库的核心函数，用于在当前进程中**创建一个新的线程**，新线程会执行指定的函数，与主线程（或其他线程）并发运行。
```c
#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, 
                   void *(*start_routine)(void *), void *arg);
```
### 核心参数与返回值
- **`thread`**：输出参数，用于存储新创建线程的唯一标识符（`pthread_t` 类型），后续操作（如等待线程、终止线程）需使用该标识符。
- **`attr`**：线程属性设置（如栈大小、优先级），通常设为 `NULL`，表示使用默认属性。
- **`start_routine`**：新线程要执行的函数指针，函数原型固定为 `void *(*)(void *)`（参数为 `void*`，返回值为 `void*`）。
- **`arg`**：传递给 `start_routine` 函数的参数，若需传递多个参数，需封装为结构体指针。
- **返回值**：成功返回 `0`；失败返回非 `0` 的错误码（注意：不设置 `errno`，需通过返回值判断错误）。
### 基础示例：创建单个线程
下面代码通过 `pthread_create` 创建一个新线程，新线程打印信息后退出，主线程等待新线程结束后再退出（避免主线程先退出导致新线程被强制终止）：
```c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
// 新线程要执行的函数（符合 void* (*)(void*) 原型）
void *thread_func(void *arg) {
    char *msg = (char *)arg; // 接收主线程传递的参数
    for (int i = 0; i < 3; i++) {
        printf("新线程：%s（第 %d 次）\n", msg, i+1);
        sleep(1); // 模拟耗时操作
    }
    return (void *)100; // 线程退出时返回值（可被主线程捕获）
}

int main() {
    pthread_t tid; // 存储新线程的 ID
    char *msg = "Hello from Main Thread";
    int ret;

    // 1. 创建新线程
    ret = pthread_create(&tid, NULL, thread_func, (void *)msg);
    if (ret != 0) {
        printf("线程创建失败！错误码：%d\n", ret);
        return 1;
    }

    // 主线程执行自己的逻辑
    for (int i = 0; i < 2; i++) {
        printf("主线程：正在运行（第 %d 次）\n", i+1);
        sleep(1);
    }

    // 2. 等待新线程结束（避免主线程先退出），并获取线程返回值
    void *thread_ret;
    ret = pthread_join(tid, &thread_ret);
    if (ret != 0) {
        printf("等待线程失败！错误码：%d\n", ret);
        return 1;
    }
    printf("新线程已退出，返回值：%ld\n", (long)thread_ret);

    return 0;
}
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#### `pthread_join`（线程等待函数）
`pthread_join` 用于**阻塞当前调用线程**，直到指定的目标线程执行结束，同时可回收目标线程的资源并`获取其退出返回值`
```c
#include <pthread.h>
int pthread_join(pthread_t thread, void **retval);
```
- **`thread`**：输入参数，需等待的目标线程的唯一标识符（`pthread_t` 类型），由 `pthread_create` 生成。
- **`retval`**：输出参数，指针的指针，用于存储目标线程的退出返回值（即目标线程函数 `start_routine` 的返回值）。若无需获取返回值，可设为 `NULL`。
- **返回值**：成功返回 `0`；失败返回非 `0` 的错误码（不设置 `errno`，需通过返回值判断错误，如目标线程已被等待过会返回 `EINVAL`）。


### 核心作用
1. **阻塞等待**：调用 `pthread_join` 的线程（通常是主线程）会暂停执行，直到目标线程结束后才继续往下运行。
2. **资源回收**：避免目标线程成为“僵尸线程”（线程结束后资源未回收，占用系统资源），`pthread_join` 会主动回收目标线程的栈、寄存器等资源。
3. **获取返回值**：通过 `retval` 参数获取目标线程的退出状态，例如判断线程是正常结束还是异常退出。
### 关键注意事项
1. **不可重复等待**：同一个目标线程只能被 `pthread_join` 等待一次，若对已等待过的线程再次调用，会返回 `EINVAL` 错误。
2. **返回值内存安全**：目标线程的返回值（`start_routine` 的返回值）不能是栈上的局部变量（线程结束后栈空间会释放，返回值无效），需用 `malloc` 动态分配内存，或使用全局/静态变量，且主线程获取后需手动释放（若为动态分配）。
3. **分离线程不可等待**：若目标线程通过 `pthread_detach` 设为“分离状态”（自动回收资源），则无法再用 `pthread_join` 等待，否则会返回 `EINVAL` 错误。
4. **主线程必等**：若主线程不调用 `pthread_join` 等待子线程，主线程先退出会导致子线程被内核强制终止（资源可能无法正常回收），除非子线程已设为分离状态。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#### `pthread_detach`（线程分离函数）
`pthread_detach` 是 POSIX 线程库的重要函数，用于将指定线程设置为**分离状态（detached）**。处于分离状态的线程在终止时会**自动释放所有资源**，无需其他线程调用 `pthread_join` 等待回收，适合无需获取线程返回值的场景。
```c
#include <pthread.h>
int pthread_detach(pthread_t thread);
```
- **`thread`**：输入参数，需要设置为分离状态的线程标识符（`pthread_t` 类型），由 `pthread_create` 生成。
- **返回值**：成功返回 `0`；失败返回非 `0` 的错误码（不设置 `errno`，常见错误如线程不存在或已被分离）。

### 核心作用
1. **自动资源回收**：分离状态的线程终止后，系统会自动回收其栈、寄存器等资源，避免“僵尸线程”（线程终止后资源未释放）占用系统资源。
2. **无需 `pthread_join`**：分离线程不能被 `pthread_join` 等待（调用会返回错误），因此适合不需要获取线程返回值的场景，简化代码逻辑。
### 关键注意事项
1. **不可逆转性**：线程一旦被设置为分离状态，就无法再恢复为非分离状态（joinable），也不能被 `pthread_join` 等待，否则会返回 `EINVAL` 错误。
2. **适用场景**：适合“后台任务”（如下载文件、日志记录）等无需主线程获取结果的场景；若需要获取线程返回值，必须使用非分离线程并配合 `pthread_join`。
3. **资源释放时机**：分离线程终止后会立即释放资源，因此其返回值（`pthread_exit` 的参数）会被忽略，无法被其他线程获取。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
| **对比维度**       | `pthread_join`                          | `pthread_detach`                        |
|--------------------|-----------------------------------------|-----------------------------------------|
| **核心功能**       | 阻塞等待目标线程终止，回收资源并获取返回值 | 将线程设为分离状态，使其终止后自动释放资源 |
| **阻塞性**         | 阻塞调用线程（如主线程会暂停等待）        | 非阻塞（仅设置状态，立即返回）           |
| **资源回收方式**   | 手动回收（需显式调用才能释放目标线程资源） | 自动回收（线程终止时系统自动释放资源）   |
| **返回值获取**     | 可通过参数获取目标线程的退出返回值        | 无法获取返回值（线程终止后返回值被丢弃） |
| **调用限制**       | 同一线程只能被调用一次（重复调用报错）    | 同一线程只能被调用一次（重复调用报错）  |
 
`pthread_join` 是“主动等待回收 + 获取结果”，`pthread_detach` 是“自动后台回收 + 无需结果”。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`pthread_exit` 作用是**终止当前调用它的线程**，并可向等待该线程的 `pthread_join` 传递线程的退出状态（返回值）。
- **函数原型**：`void pthread_exit(void *retval);`
  - 参数 `retval`：指向线程退出状态的指针，仅当其他线程通过 `pthread_join` 等待该线程时，才能获取到这个状态值（若无需传递状态，可设为 `NULL`）。
  - 注意：`retval` 不能指向线程栈上的局部变量（线程终止后栈空间会释放，指针会变为野指针），通常指向全局变量或用 `malloc` 分配的堆内存。
### 关键特性
1. **只终止当前线程**：与 `exit()`（终止整个进程）不同，`pthread_exit` 仅结束调用它的线程，进程内其他线程不受影响，会继续执行。
2. **配合 `pthread_join` 传递状态**：若线程 A 调用 `pthread_exit(&status)`，线程 B 可通过 `pthread_join(A, &ret_val)` 获取 `status` 的值（此时 `ret_val` 会指向 `status`）。
3. **自动清理线程资源**：线程终止后，其占用的栈空间、寄存器等资源会被系统回收（若未被 `pthread_join` 等待，线程会变为“僵尸线程”，需通过 `pthread_detach` 或 `pthread_join` 清理）。
### 示例代码
```c
#include <pthread.h>
#include <stdio.h>
// 全局变量，用于传递线程退出状态
int g_thread_result = 0;
void *thread_func(void *arg) {
    int count = *(int *)arg;
    for (int i = 0; i < count; i++) {
        printf("子线程执行中...\n");
    }
    // 线程终止，传递退出状态（指向全局变量）
    g_thread_result = count * 2;
    pthread_exit(&g_thread_result);
}
int main() {
    pthread_t tid;
    int arg = 3;
    void *ret_val;  // 用于接收子线程的退出状态
    // 创建子线程
    pthread_create(&tid, NULL, thread_func, &arg);
    // 等待子线程终止，并获取其退出状态
    pthread_join(tid, &ret_val);
    // 打印子线程传递的退出状态
    printf("子线程退出，返回值：%d\n", *(int *)ret_val);
    return 0;
}
```
### 注意事项
- **避免传递局部变量地址**：若 `retval` 指向线程栈上的局部变量（如 `int val=5; pthread_exit(&val);`），线程终止后栈空间释放，`pthread_join` 获取的指针会是野指针，访问时会导致内存错误。
- **主线程退出的影响**：若主线程未调用 `pthread_join` 等待子线程，直接调用 `pthread_exit`，主线程会终止，但子线程会继续执行；若主线程调用 `exit()`，则整个进程（包括所有子线程）会立即终止。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#### `pthread_cancel()` 用于请求终止指定的线程。它的原型如下：
```c
#include <pthread.h>
int pthread_cancel(pthread_t thread);
```
#### 工作机制
1. 这只是一个"请求"，而不是强制终止，线程可以选择是否响应这个请求
2. 线程是否以及何时响应取消请求，取决于它的取消状态和取消类型：
   - 取消状态：可以是可取消（`PTHREAD_CANCEL_ENABLE`）或不可取消（`PTHREAD_CANCEL_DISABLE`）
   - 取消类型：可以是延迟取消（`PTHREAD_CANCEL_DEFERRED`，默认）或异步取消（`PTHREAD_CANCEL_ASYNCHRONOUS`）
#### 返回值
- 成功：返回 0
- 失败：返回非 0 错误码（如 `ESRCH` 表示线程不存在）
#### 注意事项
1. 当线程被取消时，它会执行清理函数（通过 `pthread_cleanup_push()` 注册）
2. 线程可以通过 `pthread_setcancelstate()` 和 `pthread_setcanceltype()` 调整其取消行为
3. 某些系统调用可能是"取消点"，当线程在这些点阻塞时会响应取消请求
### 取消点函数
**取消点（cancellation points）** 是指线程可能响应取消请求的特定函数或执行点。当线程处于可取消状态（`PTHREAD_CANCEL_ENABLE`）且收到取消请求时，会在到达下一个取消点时终止。
1. **线程相关函数**
   - `pthread_join()`：等待线程结束
   - `pthread_cond_wait()`/`pthread_cond_timedwait()`：条件变量等待
   - `pthread_testcancel()`：显式测试取消请求的函数
2. **I/O 操作函数**
   - `read()`/`write()`：文件读写
   - `recv()`/`send()`：网络数据收发
   - `accept()`/`connect()`：网络连接操作
   - `select()`/`poll()`：I/O 多路复用
3. **时间相关函数**
   - `sleep()`：休眠指定秒数
   - `nanosleep()`：高精度休眠
   - `clock_nanosleep()`：基于时钟的休眠
4. **其他常用函数**
   - `wait()`/`waitpid()`：等待子进程结束
   - `sem_wait()`：信号量等待
   - `sigwait()`：等待信号
**自定义取消点**：如果线程执行的代码中没有上述取消点函数，可以通过调用 `pthread_testcancel()` 手动插入取消点。
#### cancel总结
| 概念                | 核心作用                                  | 关键取值/行为                                                                 |
|---------------------|-------------------------------------------|-------------------------------------------------------------------------------|
| **取消状态**        | 开关：决定线程“是否允许”响应取消请求      | - `PTHREAD_CANCEL_ENABLE`（允许响应，默认）<br>- `PTHREAD_CANCEL_DISABLE`（禁止响应） |
| **取消类型**        | 定时器：决定允许响应时“何时”响应          | - 延迟取消（默认）：仅在**取消点**（如 `sleep()`、`pthread_testcancel()`）响应<br>- 异步取消：收到请求后**立即**响应（无论当前执行到哪一步） |
在 POSIX 线程中，取消状态和取消类型可以通过专门的函数进行设置，分别是 `pthread_setcancelstate()`（设置取消状态）和 `pthread_setcanceltype()`（设置取消类型）。这两个函数需要在线程内部调用，用于调整当前线程的取消行为。

#### 一、设置取消状态（`pthread_setcancelstate()`）
**作用**：控制线程是否允许响应取消请求（开关功能）。
```c
#include <pthread.h>
// 参数1：新的取消状态（必选）
// 参数2：输出参数，用于保存线程之前的取消状态（可选，传NULL则不保存）
int pthread_setcancelstate(int state, int *oldstate);
```
#### 参数说明
- **`state`（新状态）**：
  - `PTHREAD_CANCEL_ENABLE`：允许线程响应取消请求（默认值）。
  - `PTHREAD_CANCEL_DISABLE`：禁止线程响应取消请求，取消请求会被挂起，直到状态改回允许。
- **返回值**：成功返回 0，失败返回非 0 错误码（如 `EINVAL` 表示参数无效）。

### 二、设置取消类型（`pthread_setcanceltype()`）
**作用**：在取消状态为“允许响应”时，控制线程何时响应取消请求（时机功能）。

#### 函数原型
```c
#include <pthread.h>
// 参数1：新的取消类型（必选）
// 参数2：输出参数，用于保存线程之前的取消类型（可选，传NULL则不保存）
int pthread_setcanceltype(int type, int *oldtype);
```
#### 参数说明
- **`type`（新类型）**：
  - `PTHREAD_CANCEL_DEFERRED`：延迟取消（默认值），仅在“取消点”响应取消请求。
  - `PTHREAD_CANCEL_ASYNCHRONOUS`：异步取消，收到请求后立即响应（无论是否在取消点）。
- **返回值**：成功返回 0，失败返回非 0 错误码（如 `EINVAL` 表示参数无效）。


