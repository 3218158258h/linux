### GThread 线程池
#### 一般流程
- 初始化（g_thread_pool_new）：创建并初始化线程池，指定任务处理函数、最大线程数等参数。
- 添加任务（g_thread_pool_push）：向线程池提交任务，任务将被线程池中的线程异步执行。
- 等待所有任务完成（g_thread_pool_free）：可选操作，等待所有任务执行完毕后销毁线程池。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
### 创建线程池
`g_thread_pool_new` 是 GLib 库中用于创建线程池的函数，线程池可以管理一组线程，高效处理多个并发任务。

```c
#include <glib.h>

GThreadPool* g_thread_pool_new(
    GFunc func,               // 任务处理函数
    gpointer user_data,       // 传递给所有任务的共享数据
    gint max_threads,         // 最大线程数，0 表示使用默认值（通常为 CPU 核心数）
    gboolean exclusive,       // 若为 TRUE，线程池销毁前其他线程无法创建
    GError **error            // 错误信息输出
);
```

#### 参数说明
- `func`：类型为 `void (*GFunc)(gpointer data, gpointer user_data)`，处理单个任务的函数
- `user_data`：传递给所有任务的共享数据，可在 `func` 中访问
- `max_threads`：线程池中允许的最大线程数量，超过此数量的任务会排队等待
- `exclusive`：线程池的独占性，通常设为 `FALSE`
- `error`：用于存储错误信息的指针，`NULL` 表示忽略错误

#### 返回值
- 成功：返回新创建的 `GThreadPool` 指针
- 失败：返回 `NULL`，并通过 `error` 输出错误信息

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
### 向线程池添加任务
`g_thread_pool_push` 用于向已创建的线程池提交任务，任务会被放入队列，等待线程池中的线程处理。

```c
#include <glib.h>

gboolean g_thread_pool_push(
    GThreadPool *pool,        // 目标线程池
    gpointer data,            // 任务数据，将传递给任务处理函数
    GError **error            // 错误信息输出
);
```

#### 参数说明
- `pool`：已初始化的 `GThreadPool` 实例
- `data`：单个任务的私有数据，类型为 `gpointer`（可通过 `GINT_TO_POINTER` 等宏转换基本类型）
- `error`：错误信息输出，`NULL` 表示忽略错误

#### 返回值
- 成功：返回 `TRUE`
- 失败：返回 `FALSE`（如线程池已销毁）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
### 销毁线程池
`g_thread_pool_free` 用于销毁线程池，释放相关资源，可选择等待所有任务完成后再销毁。

```c
#include <glib.h>

void g_thread_pool_free(
    GThreadPool *pool,        // 要销毁的线程池
    gboolean immediate,       // 若为 TRUE，立即销毁（未执行的任务被丢弃）；FALSE 则等待所有任务完成
    gboolean wait             // 若为 TRUE，当前线程阻塞等待销毁完成
);
```

#### 参数说明
- `pool`：要销毁的 `GThreadPool` 实例
- `immediate`：是否立即终止未执行的任务
- `wait`：是否阻塞等待销毁过程完成

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
### 线程池属性控制
#### 获取/设置最大线程数
```c
// 获取当前最大线程数
gint g_thread_pool_get_max_threads(GThreadPool *pool);

// 修改最大线程数
void g_thread_pool_set_max_threads(
    GThreadPool *pool,
    gint max_threads,
    GError **error
);
```

#### 获取当前活跃线程数
```c
gint g_thread_pool_get_num_threads(GThreadPool *pool);
```

#### 获取等待中的任务数
```c
gint g_thread_pool_unprocessed(GThreadPool *pool);
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
### 单池处理多类型任务
GLib线程池默认绑定一个处理函数，但可通过设计任务数据结构实现多类型任务处理，核心思路是在任务数据中包含类型标识，在统一处理函数中分支执行不同逻辑。

#### 实现步骤
1. **定义任务类型枚举**：区分不同任务类型
2. **设计任务数据结构体**：包含类型标识和对应类型的参数
3. **实现统一处理函数**：根据任务类型执行对应逻辑
4. **创建不同类型任务**：按类型填充数据并提交到线程池

#### 示例代码
```c
#include <glib.h>
#include <stdio.h>

// 1. 定义任务类型枚举
typedef enum {
    TASK_TYPE_PRINT,    // 打印任务
    TASK_TYPE_CALCULATE,// 计算任务
    TASK_TYPE_SAVE      // 保存任务
} TaskType;

// 2. 定义任务数据结构体
typedef struct {
    TaskType type;      // 任务类型
    union {
        char *print_str;       // 打印任务参数
        int calculate_num;     // 计算任务参数
        struct {               // 保存任务参数
            char *filename;
            char *content;
        } save_data;
    } data;             // 任务具体数据
} Task;

// 3. 统一任务处理函数
void task_handler(gpointer data, gpointer user_data) {
    Task *task = (Task*)data;
    const char *shared_info = (const char*)user_data;
    
    // 根据任务类型执行不同逻辑
    switch (task->type) {
        case TASK_TYPE_PRINT:
            g_print("[%s] 打印任务：%s\n", shared_info, task->data.print_str);
            g_free(task->data.print_str);  // 释放动态分配的字符串
            break;
            
        case TASK_TYPE_CALCULATE:
            g_print("[%s] 计算任务：%d 的平方是 %d\n",
                   shared_info,
                   task->data.calculate_num,
                   task->data.calculate_num * task->data.calculate_num);
            break;
            
        case TASK_TYPE_SAVE:
            g_print("[%s] 保存任务：将内容写入 %s\n",
                   shared_info,
                   task->data.save_data.filename);
            // 这里可以添加实际文件写入逻辑
            g_free(task->data.save_data.filename);
            g_free(task->data.save_data.content);
            break;
    }
    
    g_free(task);  // 释放任务结构体
}

int main(int argc, char *argv[]) {
    // 初始化GLib线程系统
    g_thread_init(NULL);
    g_type_init();

    GError *error = NULL;
    // 创建线程池，绑定统一处理函数
    GThreadPool *pool = g_thread_pool_new(
        task_handler,           // 统一处理函数
        "共享信息",              // 传递给所有任务的共享数据
        3,                       // 最大3个线程
        FALSE,                   // 非独占模式
        &error
    );

    if (error != NULL) {
        g_print("创建线程池失败：%s\n", error->message);
        g_error_free(error);
        return 1;
    }

    // 4. 添加不同类型的任务
    // 添加打印任务
    Task *print_task = g_new(Task, 1);
    print_task->type = TASK_TYPE_PRINT;
    print_task->data.print_str = g_strdup("Hello from print task");
    g_thread_pool_push(pool, print_task, NULL);

    // 添加计算任务
    Task *calc_task = g_new(Task, 1);
    calc_task->type = TASK_TYPE_CALCULATE;
    calc_task->data.calculate_num = 15;
    g_thread_pool_push(pool, calc_task, NULL);

    // 添加保存任务
    Task *save_task = g_new(Task, 1);
    save_task->type = TASK_TYPE_SAVE;
    save_task->data.save_data.filename = g_strdup("output.txt");
    save_task->data.save_data.content = g_strdup("Sample content");
    g_thread_pool_push(pool, save_task, NULL);

    // 等待所有任务完成后销毁线程池
    g_print("等待所有任务完成...\n");
    g_thread_pool_free(pool, FALSE, TRUE);
    g_print("所有任务处理完毕，线程池已销毁\n");

    return 0;
}
```

#### 编译命令
```bash
gcc -o multi_task_pool multi_task_pool.c `pkg-config --cflags --libs glib-2.0`
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
### 注意事项
1. **线程安全**：GLib 线程池本身是线程安全的，可在多线程中同时调用 `g_thread_pool_push`
2. **任务数据生命周期**：任务数据（`data`）必须在任务执行期间保持有效，建议使用 `g_malloc`/`g_new` 分配并在任务函数中释放
3. **错误处理**：创建线程池和添加任务时应检查 `error`，避免资源泄漏
4. **线程池销毁后**：不能再向已销毁的线程池添加任务，否则会返回错误
5. **内存管理**：使用 GLib 内存管理函数（`g_new`/`g_free`/`g_strdup` 等）保持一致性，避免内存泄漏

